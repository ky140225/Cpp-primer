# 第3章 字符串、 向量和数组  

本章将介绍两种最重要的标准库类型： string和vector。 string表示可变长的字符序列， vector存放的是某种给定类型对象的可变长序列。 本章还将介绍内置数组类型， 和其他内置类型一样， 数组的实现与硬件密切相关。 因此相较于标准库类型string和vector， 数组在灵活性上稍显不足。  



## 3.1 命名空间的using声明  

目前为止，我们用到的库函数基本上都属于命名空间std，而程序也显式地将这一点标示了出来。 **例如，std::cin表示从标准输入中读取内容。 此处使用作用域操作符（::）（参见1.2节， 第7页） 的含义是： 编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字。 因此， std::cin的意思就是要使用命名空间std中的名字cin。**  

本节将学习其中一种最安全的方法，也就是使用using声明（using declaration） ，18.2.2节（第702页）会介绍另一种方法  

有了using声明就无须专门的前缀（形如命名空间::） 也能使用所需的名字了。 using声明具有如下的形式：

```c++
using namespace::name;
```

一旦声明了上述语句， 就可以直接访问命名空间中的名字：  

```c++
#include <iostream>
//using声明，当我们使用名字cin时，从命名空间std中获取它
using std::cin;
int main()	
{
	int i;
	cin >> i;			// 正确：cin和std::cin含义相同
	cout << i;			// 错误：没有对应的using声明，必须使用完整的名字
	std::cout << i;		// 正确：显式地从std中使用cout
	return 0;
}
```



#### 每个名字都需要独立的using声明

按照规定， 每个using声明引入命名空间中的一个成员。 例如， 可以把要用到的标准库中的名字都以using声明的形式表示出来

```c++
#include <iostream>
//通过下列using声明，我们可以使用标准库中的名字
using std:cin;
using std::cout;using std:endl;

int main()
{
	cout << "Enter two numbers:" << endl;
	int v1, v2;
	cin >> v1 >> v2;
	cout << "The sum of " << v1 << and " << v2
	<< " is " << v1 + v2 << endl;
	return 0;
}
```

在上述程序中， 一开始就有对cin、 cout和endl的using声明， 这意味着我们不用再添加std:: 形式的前缀就能直接使用它们。 C++语言的形式比较自由， 因此既可以一行只放一条using声明语句， 也可以一行放上多条。 不过要注意， **用到的每个名字都必须有自己的声明语句， 而且每句话都得以分号结束。**



#### 头文件不应包含using声明

位于头文件的代码（参见2.6.3节， 第67页） 一般来说不应该使用using声明。 这是因为头文件的内容会拷贝到所有引用它的文件中去， 如果头文件里有某个using声明， 那么每个使用了该头文件的文件就都会有这个声明。 对于某些程序来说， 由于不经意间包含了一些名字， 反而可能产生始料未及的名字冲突。  



## 3.2 标准库类型string

标准库类型string表示可变长的字符序列， 使用string类型必须首先包含string头文件。 作为标准库的一部分， string定义在命名空间std中。接下来的示例都假定已包含了下述代码：  

```c++
#include <string>
using std::string;
```



### **3.2.1 定义和初始化string对象**

如何初始化类的对象是由类本身决定的。 一个类可以定义很多种初始化对象的方式， 只不过这些方式之间必须有所区别： 或者是初始值的数量不同， 或者是初始值的类型不同。 表3.1列出了初始化string对象最常用的一些方式

![表3.1 初始化string对象的方式](C:\Users\Grey\Desktop\C++ Primer\图片\表3.1 初始化string对象的方式.png)



#### 直接初始化和拷贝初始化

由2.2.1节（第39页） 的学习可知， C++语言有几种不同的初始化方式， 通过string我们可以清楚地看到在这些初始化方式之间到底有什么区别和联系。 **如果使用等号（=） 初始化一个变量，实际上执行的是拷贝初始化（copy initialization），编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化（direct initialization）**

**当初始值只有一个时， 使用直接初始化或拷贝初始化都行。** 如果像上面的s4那样初始化**要用到的值有多个， 一般来说只能使用直接初始化的方式：**  

```C++
string s5 = "hiya";				// 拷贝初始化
string s6("hiya");				// 直接初始化
string s7(10, 'c');				// 直接初始化，s7的内容是cccccccccc
```

对于用多个值进行初始化的情况， 非要用拷贝初始化的方式来处理也不是不可以， 不过需要显式地创建一个（临时） 对象用于拷贝：

```C++
string temp(10, 'c');			// temp的内容是cccccccccc
string s8 = temp;				// 将temp拷贝给s8
```

s8的初始值是string（10， 'c'） ， 它实际上是用数字10和字符c两个参数创建出来的一个string对象， 然后这个string对象又拷贝给了s8。 这条语句本质上等价于下面的两条语句： 其实我们可以看到，尽管初始化s8的语句合法，但和初始化s7的方式比较起来可读性较差， 也没有任何补偿优势。  



### 3.2.2 string对象上的操作

一个类除了要规定初始化其对象的方式外， 还要定义对象上所能执行的操作。 其中， 类既能定义通过函数名调用的操作， 就像Sales_item类的isbn函数那样（参见1.5.2节， 第20页） ， 也能定义<<、+等各种运算符在该类对象上的新含义。 表3.2中列举了string的大多数操作。  

![表3.2 string的操作](C:\Users\Grey\Desktop\C++ Primer\图片\表3.2 string的操作.png)



#### 读写string对象  

第1章曾经介绍过， 使用标准库中的iostream来读写int、 double等内置类型的值。 同样， 也可以使用IO操作符读写string对象：  

```c++
// 注意：要想编译下面的代码还需要适当的#include语句和using声明
int main()
{
	string s;					// 空字符串
	cin >> s;					// 将string对象读入s,遇到空白停止
	cout << s << endl;			// 输出s
	return 0;
}
```

这段程序首先定义一个名为s的空string， 然后将标准输入的内容读取到s中。**在执行读取操作时， string对象会自动忽略开头的空白（即空格符、 换行符、 制表符等） 并从第一个真正的字符开始读起， 直到遇见下一处空白为止。**  

如上所述，如果程序的输入是“ Hello World! ”（注意开头和结尾处的空格），则输出将是 “Hello” ， 输出结果中没有任何空格。

和内置类型的输入输出操作一样， string对象的此类操作也是返回运算符左侧的运算对象作为其结果。 因此， 多个输入或者多个输出可以连写在一起  

```c++
string s1, s2;
cin >> s1 >> s2;					// 把第一个输入读到s1中，第二个输入读到s2中
cout << s1 << s2 << endl;			// 输出两个string对象
```

假设给上面这段程序输入与之前一样的内容“ Hello World! ”，输出将是“HelloWorld!”。  



#### 读取未知数量的string对象

1.4.3节（第13页） 的程序可以读入数量未知的整数， 下面编写一个类似的程序用于读取string对象：  

```c++
int main()
{
	string word;
	while (cin >> word)	 // 反复读取，直至到达文件末尾
		cout << word << endl;	 // 逐个输出单词，每个单词后面紧跟一个换行
	return 0;
}
```

在该程序中， 读取的对象是string而非int， 但是while语句的条件部分和之前版本的程序是一样的。 该条件负责在读取时检测流的情况， 如果流有效， 也就是说没遇到文件结束标记或非法输入， 那么执行while语句内部的操作。 此时， 循环体将输出刚刚从标准输入读取的内容。 重复若干次之后， 一旦遇到文件结束标记或非法输入循环也就结束了。



#### 使用getline读取一整行

有时我们希望能在最终得到的字符串中保留输入时的空白符， 这时应该用getline函数代替原来的>>运算符。**getline函数的参数是一个输入流和一个string对象， 函数从给定的输入流中读入内容， 直到遇到换行符为止（注意换行符也被读进来了） ， 然后把所读的内容存入到那个string对象中去（注意不存换行符） 。 getline只要一遇到换行符就结束读取操作并返回结果， 哪怕输入的一开始就是换行符也是如此。 如果输入真的一开始就是换行符， 那么所得的结果是个空string。**  

**和输入运算符一样， getline也会返回它的流参数。** 因此既然输入运算符能作为判断的条件（参见1.4.3节， 第13页） ， 我们也能用getline的结果作为条件。 例如， 可以通过改写之前的程序让它一次输出一整行，而不再是每行输出一个词了：  

```c++
int main()
{
	string line;				
    // 每次读入一整行，直至到达文件末尾
	while (getline(cin, line))
		cout << line << endl;
	return 0;
}
```

因为line中不包含换行符， 所以我们手动地加上换行操作符。 **和往常一样， 使用endl结束当前行并刷新显示缓冲区。**  

<u>触发getline函数返回的那个换行符实际上被丢弃掉了， 得到的string对象中并不包含该换行符。</u>  



#### string的empty和size操作

顾名思义，empty函数根据string对象是否为空返回一个对应的布尔值（参见第2.1节， 30页） 。 和Sales_item类（参见1.5.2节， 第20页） 的isbn成员一样， empty也是string的一个成员函数。 调用该函数的方法很简单， 只要使用点操作符指明是哪个对象执行了empty函数就可以了。
​		通过改写之前的程序， 可以做到只输出非空的行：  

```c++
// 每次读入一整行，遇到空行直接跳过
while (getline(cin, line))
	if (!line.empty())
		cout << line << endl;
```

在上面的程序中， if语句的条件部分使用了逻辑非运算符（ ! ） ，它返回与其运算对象相反的结果。 此例中， 如果str不为空则返回真。

**size函数返回string对象的长度（即string对象中字符的个数）**，可以使用size函数只输出长度超过80个字符的行：  

```c++
string line;
// 每次读入一整行，输出其中超过80个字符的行
while (getline(cin, line))
	if (1ine.size() > 80)
		cout << line << endl;
```



#### string::size_type类型

对于size函数来说，返回一个int或者如前面2.1.1节( 第31页) 所述的那样返回一个unsigned似乎都是合情合理的。但其实size函数返回的是一个string::size_type类型的值  

在具体使用的时候， 通过作用域操作符来表明名字size_type是在类string中定义的。  

尽管我们不太清楚string::size_type类型的细节， 但有一点是肯定的：**它是一个无符号类型的值（参见2.1.1节， 第30页） 而且能足够存放下任何string对象的大小。 所有用于存放string类的size函数返回值的变量， 都应该是string::size_type类型的。**

在C++11新标准中， 允许编译器通过auto或者decltype（参见2.5.2节， 第61页） 来推断变量的类型：  

```c++
auto len = line.size();		// len的类型是string::size_type
```

**由于size函数返回的是一个无符号整型数， 因此切记， 如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果（参见2.1.2节， 第33页）** 。例如，假设n是一个具有负值的int，则表达式s.size() < n的判断结果几乎肯定是true。这是因为负值n会自动地转换成一个比较大的无符号值。

<u>**如果一条表达式中已经有了size()函数就不要再使用int了， 这样可以避免混用int和unsigned可能带来的问题。**</u>  



#### 比较string对象

string类定义了几种用于比较字符串的运算符。 这些比较运算符逐一比较string对象中的字符， 并且对大小写敏感， 也就是说， 在比较时同一个字母的大写形式和小写形式是不同的。

**相等性运算符（== 和 !=）分别检验两个string对象相等或不相等，string对象相等意味着它们的长度相同而且所包含的字符也全都相同。关系运算符<、 <=、 >、 >=分别检验一个string对象是否小于、 小于等于、 大于、 大于等于另外一个string对象。 上述这些运算符都依照（大小写敏感的） 字典顺序：**

​	1.如果两个string对象的长度不同， 而且较短string对象的每个字符都与较长string对象对应位置上的字符相同， 就说较短string对象小于较长string对象。

​	2.如果两个string对象在某些对应的位置上不一致， 则string对象比较的结果其实是string对象中第一对相异字符比较的结果。

下面是string对象比较的一个示例：  

```c++
string str = "Hello";
string phrase = "Hello World";
string slang = "Hiya";
```

根据规则1可判断， 对象str小于( < )对象phrase； 根据规则2可判断， 对象slang既大于str也大于phrase。			( slang > phrase > str )  



#### 为string对象赋值

一般来说， 在设计标准库类型时都力求在易用性上向内置类型看齐， 因此大多数库类型都支持赋值操作。 对于string类而言， 允许把一个对象的值赋给另外一个对象：  

```c++
string st1(10,'c'), st2;		// st1的内容是cccccccccc; st2是一个空字符串
st1 = st2;						// 赋值：用st2的副本替换st1的内容
								// 此时st1和st2都是空字符串
```



#### 两个string对象相加

两个string对象相加得到一个新的string对象， 其内容是把左侧的运算对象与右侧的运算对象串接而成。 也就是说， **对string对象使用加法运算符（+） 的结果是一个新的string对象， 它所包含的字符由两部分组成： 前半部分是加号左侧string对象所含的字符、 后半部分是加号右侧string对象所含的字符。 另外， 复合赋值运算符（+=） （参见1.4.1节，第10页） 负责把右侧string对象的内容追加到左侧string对象的后面：**  

```c++
string s1 "hello,", s2 = "world\n";
string s3 = s1 + s2;			// s3的内容是he11o,wor1d\n
S1 += S2;						// 等价于s1 = s1 + s2
```



#### 字面值和string对象相加

如2.1.2节（第33页） 所讲的， 即使一种类型并非所需， 我们也可以使用它， 不过前提是该种类型可以自动转换成所需的类型。 因为**标准库允许把字符字面值和字符串字面值（参见2.1.3节， 第36页） 转换成string对象**， 所以在需要string对象的地方就可以使用这两种字面值来替代。 利用这一点将之前的程序改写为如下形式：  

```c++
string s1 = "he11o", s2 = "wor1d";		// 在s1和s2中都没有标点符号
string s3 = s1 + ", " + s2 + '\n';
```

**当把string对象和字符字面值及字符串字面值混在一条语句中使用时， 必须确保每个加法运算符（+） 的两侧的运算对象至少有一个是string：**  

```c++
string s4 = sl + ", ";				// 正确：把一个string对象和一个字面值相加
string s5 = "hello" + ", ";			// 错误：两个运算对象都不是string
// 正确：每个加法运算符都有一个运算对象是string
string s6 = s1 + ", " + "world";
string s7 = "hello" + ", " + s2;	// 错误：不能把字面值直接相加
```

s4和s5初始化时只用到了一个加法运算符， 因此很容易判断是否合法。 **s6的初始化形式之前没有出现过， 但其实它的工作机理和连续输入连续输出（参见1.2节， 第6页） 是一样的， 可以用如下的形式分组：**  

```c++
string s6 = (s1 + ", " ) + "world";
```

其中子表达式s1 + "， "的结果是一个string对象， 它同时作为第二个加法运算符的左侧运算对象， 因此上述语句和下面的两个语句是等价的  

```c++
string tmp = s1 + ", ";		// 正确：加法运算符有一个运算对象是string
s6 = tmp + "world";			// 正确：加法运算符有一个运算对象是string
```

另一方面， s7的初始化是非法的， 根据其语义加上括号后就成了下面的形式：

```c++
string s7 = ("hello" + ", ") + s2;		//错误：不能把字面值直接相加
```

很容易看到， 括号内的子表达式试图把两个字符串字面值加在一起， 而编译器根本没法做到这一点， 所以这条语句是错误的。  

<u>**因为某些历史原因， 也为了与C兼容， 所以C++语言中的字符串字面值并不是标准库类型string的对象。 切记， 字符串字面值与string是不同的类型。**</u>  



### 3.2.3 处理string对象中的字符

我们经常需要单独处理string对象中的字符， 比如检查一个string对象是否包含空白， 或者把string对象中的字母改成小写， 再或者查看某个特定的字符是否出现等。

这类处理的一个关键问题是如何获取字符本身。 有时需要处理string对象中的每一个字符， 另外一些时候则只需处理某个特定的字符， 还有些时候遇到某个条件处理就要停下来。   

另一个关键问题是要知道能改变某个字符的特性。 在cctype头文件中定义了一组标准库函数处理这部分工作， 表3.3列出了主要的函数名及其含义  

![表3.3 cctype头文件中的函数](C:\Users\Grey\Desktop\C++ Primer\图片\表3.3 cctype头文件中的函数.png)



#### 处理每个字符？ 使用基于范围的for语句

**如果想对string对象中的每个字符做点什么操作， 目前最好的办法是使用C++11新标准提供的一种语句： 范围for（range for） 语句。 这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：**  

```c++
for (declaration : expression)
	statement
```

其中， **expression部分是一个对象， 用于表示一个序列。 declaration部分负责定义一个变量， 该变量将被用于访问序列中的基础元素。 每次迭代， declaration部分的变量会被初始化为expression部分的下一个元素值。**

一个string对象表示一个字符的序列， 因此string对象可以作为范围for语句中的expression部分。 举一个简单的例子， 我们可以使用范围for语句把string对象中的字符每行一个输出出来：  

```c++
string str("some string");			// 每行输出st上中的一个字符。
for (auto c : str)					// 对于str中的每个字符
	cout << c << endl;				// 输出当前字符，后面紧跟一个换行符
```

**for循环把变量c和str联系了起来， 其中我们定义循环控制变量的方式与定义任意一个普通变量是一样的。 此例中， 通过使用auto关键字（参见2.5.2节， 第61页） 让编译器来决定变量c的类型， 这里c的类型是char。 每次迭代， str的下一个字符被拷贝给c， 因此该循环可以读作“对于字符串str中的每个字符c， ”执行某某操作。 此例中的“某某操作”即输出一个字符， 然后换行。**

举个稍微复杂一点的例子， 使用范围for语句和ispunct函数来统计string对象中标点符号的个数：  

```c++
string s("Hello World!!!");
// punct cnt的类型和s.size的返回类型一样；参见2.5.3节（第62页)
decltype(s.size()) punct_cnt = 0;
// 统计s中标，点符号的数量
for (auto c : s)						// 对于s中的每个字符
	if (ispunct(c))						// 如果该字符是标点符号
		++punct_cnt;					// 将标点符号的计数值加1
	cout << punct_cnt
		<< " punctuation characters in "<< s << endl;
```

程序的输出结果将是：  

`3 punctuation characters in Hello World!!!`

这里我们使用decltype关键字（参见2.5.3节， 第62页） 声明计数变量punct_cnt， 它的类型是s.size函数返回值的类型， 也就是string::size_type。 使用范围for语句处理string对象中的每个字符并检查其是否是标点符号。 如果是， 使用递增运算符（参见1.4.1节， 第10页） 给计数变量加1。 最后， 待范围for语句结束后输出统计结果。



#### 使用范围for语句改变字符串中的字符

**如果想要改变string对象中字符的值， 必须把循环变量定义成引用类型**（参见2.3.1节， 第45页） 。记住，所谓引用只是给定对象的一个别名， 因此当使用引用作为循环控制变量时， 这个变量实际上被依次绑定到了序列的每个元素上。 使用这个引用， 我们就能改变它绑定的字符。

新的例子不再是统计标点符号的个数了， 假设我们想要把字符串改写为大写字母的形式。 为了做到这一点可以使用标准库函数toupper， 该函数接收一个字符， 然后输出其对应的大写形式。 这样， 为了把整个string对象转换成大写， 只要对其中的每个字符调用toupper函数并将结果再赋给原字符就可以了：  

```c++
string s("Hello World!!!");		// 转换成大写形式。
for (auto &c : s)				// 对于s中的每个字符（注意：c是引用)
	c = toupper(c);				// c是一个引用，因此赋值语句将改变s中字符的值
cout << s << endl;
```

上述代码的输出结果将是：

`HELLO WORLD!!!`

每次迭代时， 变量c引用string对象s的下一个字符， 赋值给c也就是在改变s中对应字符的值。 因此当执行下面的语句时，

```c++
c = toupper(c);			// c是一个引用，因此赋值语句将改变s中字符的值
```

实际上改变了c绑定的字符的值。 整个循环结束后， str中的所有字符都变成了大写形式。



#### 只处理一部分字符？  

如果要处理string对象中的每一个字符， 使用范围for语句是个好主意。 然而， 有时我们需要访问的只是其中一个字符， 或者访问多个字符但遇到某个条件就要停下来。 例如， 同样是将字符改为大写形式， 不过新的要求不再是对整个字符串都这样做， 而仅仅把string对象中的第一个字母或第一个单词大写化。

**要想访问string对象中的单个字符有两种方式： 一种是使用下标，另外一种是使用迭代器**， 其中关于迭代器的内容将在3.4节（第95页）和第9章中介绍。

**下标运算符（[ ]） 接收的输入参数是string::size_type类型的值（参见3.2.2节， 第79页） ， 这个参数表示要访问的字符的位置； 返回值是该位置上字符的引用。**

**string对象的下标从0计起。 如果string对象s至少包含两个字符， 则s[0]是第1个字符、s[1]是第2个字符、 s[s.size() -1]是最后一个字符。**  

<u>string对象的下标必须大于等于0而小于s.size() 。</u>

<u>使用超出此范围的下标将引发不可预知的结果， 以此推断， 使用下标访问空string也会引发不可预知的结果。</u>  

下标的值称作“下标”或“索引”， 任何表达式只要它的值是一个整型值就能作为索引。 不过， 如果某个索引是带符号类型的值将自动转换成由string::size_type（参见2.1.2节， 第33页） 表达的无符号类型。

下面的程序使用下标运算符输出string对象中的第一个字符：  

```c++
if(!s.empty())						// 确保确实有字符需要输出
	cout << s[0] << endl;			// 输出s的第一个字符
```

在访问指定字符之前， 首先检查s是否为空。 其实不管什么时候只要对string对象使用了下标， 都要确认在那个位置上确实有值。 如果s为空， 则s[0]的结果将是未定义的。

只要字符串不是常量（参见2.4节， 第53页） ， 就能为下标运算符返回的字符赋新值。 例如， 下面的程序将字符串的首字符改成了大写形式  

```c++
string s("some string");
if (!s.empty())						// 确保s[0]的位置确实有字符
	s[0] = toupper(s[0]);			// 为s的第一个字符赋一个新值
```

程序的输出结果将是：

`Some string`



#### 使用下标执行迭代

另一个例子是把s的第一个词改成大写形式：  

```c++
//依次处理S中的字符直至我们处理完全部字符或者遇到一个空白
for (decltype(s.size()) index = 0;
		index != s.size() && !isspace(s[index]); ++index)
			s[index] = toupper(s[index]);			// 将当前字符改成大写形式
```

程序的输出结果将是：

`SOME string`

在上述程序中， for循环使用变量index作为s的下标， index的类型是由decltype关键字决定的。 首先把index初始化为0， 这样第一次迭代就会从s的首字符开始； 之后每次迭代将index加1以得到s的下一个字符。 循环体负责将当前的字母改写为大写形式。

for语句的条件部分涉及一点新知识， 该条件使用了逻辑与运算符（&&）。 如果参与运算的两个运算对象都为真， 则逻辑与结果为真；否则结果为假。 对这个运算符来说最重要的一点是， C++语言规定只有当左侧运算对象为真时才会检查右侧运算对象的情况。 如此例所示， 这条规定确保了只有当下标取值在合理范围之内时才会真的用此下标去访问字符串。 也就是说， 只有在index达到s.size() 之前才会执行s[index]。 随着index的增加， 它永远也不可能超过s.size() 的值， 所以可以确保index比s.size() 小。  



<u>提示： 注意检查下标的合法性</u>

<u>使用下标时必须确保其在合理范围之内， 也就是说， 下标必须大于等于0而小于字符串的size() 的值。 一种简便易行的方法是， **总是设下标的类型为string::size_type， 因为此类型是无符号数， 可以确保下标不会小于0。 此时， 代码只需保证下标小于size() 的值就可以了。**</u>  



#### 使用下标执行随机访问

在之前的示例中， 我们让字符串的下标每次加1从而按顺序把所有字符改写成了大写形式。 其实也能通过计算得到某个下标值， 然后直接获取对应位置的字符，并不是每次都得从前往后依次访问。

例如， 想要编写一个程序把0到15之间的十进制数转换成对应的十六进制形式， 只需初始化一个字符串令其存放16个十六进制“数字”：  

```c++
const string hexdigits = "0123456789ABCDEF";		// 可能的十六进制数字

cout << "Enter a series of numbers between 0 and 15"
	 << " separated by spaces.Hit ENTER when finished: "
	 << endl;

string result;							// 用于保存十六进制的字符串
string:size_type n;						// 用于保存从输入流读取的数

while (cin >> n)
	if (n < hexdigits.size())			// 忽略无效输入
		result += hexdigits[n];			// 得到对应的十六进制数字
cout << "Your hex number is:" << result << endl;
```

假设输入的内容如下：

`12 0 5 15 8 15`

程序的输出结果将是：

`Your hex number is: C05F8F`

上述程序的执行过程是这样的： 首先初始化变量hexdigits令其存放从0到F的十六进制数字， 注意我们把hexdigits声明成了常量（参见2.4节， 第53页） ， 这是因为在后面的程序中不打算再改变它的值。 在循环内部使用输入值n作为hexdigits的下标， hexdigits[n]的值就是hexdigits内位置n处的字符。 例如， 如果n是15， 则结果是F； 如果n是12， 则结果是C， 以此类推。 把得到的十六进制数字添加到result内， 最后一并输出。

无论何时用到字符串的下标， 都应该注意检查其合法性。 在上面的程序中， **下标n是string::size_type类型， 也就是无符号类型， 所以n可以确保大于或等于0。 在实际使用时， 还需检查n是否小于hexdigits的长度。**  



## 3.3 标准库类型vector

标准库类型vector表示对象的集合， 其中所有对象的类型都相同。 集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为vector“容纳着”其他对象，所以它常被称作容器(container)

要想使用vector， 必须包含适当的头文件。  

```c++
#include<vector>
using std::vector;
```

C++语言既有类模板（class template）,  也有函数模板， 其中**vector是一个类模板。**  

**模板本身不是类或函数， 相反可以将模板看作为编译器生成类或函数编写的一份说明。 编译器根据模板创建类或函数的过程称为实例化**（instantiation） ，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

**对于类模板来说， 我们通过提供一些额外信息来指定模板到底实例化成什么样的类， 需要提供哪些信息由模板决定。** 提供信息的方式总是这样： 即在模板名字后面跟一对尖括号， 在括号内放上信息。以vector为例， 提供的额外信息是vector内所存放对象的类型：  

```c++
vector<int> ivec;							// ivec保存int类型的对象
vector<Sales_item> Sales_vec;				// 保存Sales_item类型的对象
vector<vector<string>> file;				// 该向量的元素是vector对象
```

在上面的例子中， 编译器根据模板vector生成了三种不同的类型：vector<int>、 vector<Sales_item> 和 vector<vector<string>>。  

<u>vector是模板而非类型， 由vector生成的类型必须包含vector中元素的类型， 例如vector<int>。</u>  

**vector能容纳绝大多数类型的对象作为其元素， 但是因为引用不是对象（参见2.3.1节， 第45页） ， 所以不存在包含引用的vector。 除此之外， 其他大多数（非引用） 内置类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector。**

需要指出的是， 在早期版本的C++标准中如果vector的元素还是vector( 或者其他模板类型 ) ，则其定义的形式与现在的C++11新标准略有不同。过去，必须在外层vector对象的右尖括号和其元素类型之间添加一个空格, 如应该写成vector<vector<int> >而非vector<vector<int>>。  



### 3.3.1 定义和初始化vector对象

和任何一种类类型一样， vector模板控制着定义和初始化向量的方法。 表3.4列出了定义vector对象的常用方法。  

![表3.4 初始化 vector 对象的方法](C:\Users\Grey\Desktop\C++ Primer\图片\表3.4 初始化 vector 对象的方法.png)

可以默认初始化vector对象（参见2.2.1节， 第40页） ， 从而创建一个指定类型的空vector：

```c++
vector<string> svec;			// 默认初始化，svec不含任何元素
```

看起来空vector好像没什么用， 但是很快我们就会知道程序在运行时可以很高效地往vector对象中添加元素。 事实上， **最常见的方式就是先定义一个空vector， 然后当运行时获取到元素的值后再逐一添加。**  

当然也可以在定义vector对象时指定元素的初始值。 例如， 允许把一个vector对象的元素拷贝给另外一个vector对象。 此时， 新vector对象的元素就是原vector对象对应元素的副本。 注意两个vector对象的类型必须相同：  

```c++
vector<int> ivec;					// 初始状态为空
//在此处给ivec添加一些值
vector<int> ivec2(ivec);			// 把ivec的元素拷贝给ivec2
vector<int> ivec3 = ivec;			// 把ivec的元素拷贝给ivec3
vector<string> svec(ivec2);			// 错误：svec的元素是string对象，不是int
```



#### 列表初始化vector对象

C++11新标准还提供了另外一种为vector对象的元素赋初值的方法， 即列表初始化（参见2.2.1节， 第39页） 。 此时， 用花括号括起来的0个或多个初始元素值被赋给vector对象：

```c++
vector<string> articles = {"a","an","the"};
```

上述vector对象包含三个元素： 第一个是字符串"a"， 第二个是字符串"an"， 最后一个是字符串"the"。

之前已经讲过， C++语言提供了几种不同的初始化方式（参见2.2.1节， 第39页） 。 **在大多数情况下这些初始化方式可以相互等价地使用，不过也并非一直如此。 目前已经介绍过的两种例外情况是： 其一， 使用拷贝初始化时（即使用=时） （参见3.2.1节， 第76页） ， 只能提供一个初始值； 其二， 如果提供的是一个类内初始值（参见2.6.1节， 第64页） ， 则只能使用拷贝初始化或使用花括号的形式初始化。 第三种特殊的要求是， 如果提供的是初始元素值的列表， 则只能把初始值都放在花括号里进行列表初始化， 而不能放在圆括号里：**  

```c++
vector<string> v1{"a","an","the"};			// 列表初始化
vector<string> v2("a","an","the");			// 错误
```



#### 创建指定数量的元素

还可以用vector对象容纳的元素数量和所有元素的统一初始值来初始化vector对象：  

```c++
vector<int> ivec(10, -1);			// 10个int类型的元素，每个都被初始化为-1
vector<string> svec(l0, "hi!");		// 10个string类型的元素，每个都被初始化为"hi!"
```



#### 值初始化

**通常情况下， 可以只提供vector对象容纳的元素数量而不用略去初始值。 此时库会创建一个值初始化的（value-initialized） 元素初值， 并把它赋给容器中的所有元素。 这个初值由vector对象中元素的类型决定。**

如果vector对象的元素是内置类型， 比如int， 则元素初始值自动设为0。 如果元素是某种类类型， 比如string， 则元素由类默认初始化：  

```c++
vector<int> ivec(10);			// 10个元素，每个都初始化为0
vector<string> svec(10);		// 10个元素，每个都是空string对象
```

对这种初始化的方式有两个特殊限制： 其一， **有些类要求必须明确地提供初始值（参见2.2.1节， 第40页）, 如果vector对象中元素的类型不支持默认初始化， 我们就必须提供初始的元素值。** 对这种类型的对象来说， 只提供元素的数量而不设定初始值无法完成初始化工作。

其二， **如果只提供了元素的数量而没有设定初始值， 只能使用直接初始化**：  

```c++
vector<int> vi = 10;			// 错误：必须使用直接初始化的形式指定向量大小
```

这里的10是用来说明如何初始化vector对象的， 我们用它的本意是想创建含有10个值初始化了的元素的vector对象， 而非把数字10“拷贝”到vector中。 因此， 此时不宜使用拷贝初始化， 7.5.4节（第265页） 将对这一点做更详细的介绍  



#### 列表初始值还是元素数量？

在某些情况下， 初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号。 例如， 用一个整数来初始化vector<int>时， 整数的含义可能是vector对象的容量也可能是元素的值。 类似的， 用两个整数来初始化vector<int>时， 这两个整数可能一个是vector对象的容量， 另一个是元素的初值， 也可能它们是容量为2的vector对象中两个元素的初值。 通过使用花括号或圆括号可以区分上述这些含义：  

```c++
vector<int> v1(10):				// v1有10个元素，每个的值都是0
vector<int> v2{10};				// v2有1个元素，该元素的值是10
vector<int> v3(10,1);			// v3有10个元素，每个的值都是1
vector<int> v4{10,1};			// v4有2个元素，值分别是10和1
```

**如果用的是圆括号， 可以说提供的值是用来构造（construct） vector对象的。 例如， v1的初始值说明了vector对象的容量； v3的两个初始值则分别说明了vector对象的容量和元素的初值。**

**如果用的是花括号， 可以表述成我们想列表初始化（list initialize）该vector对象。 也就是说， 初始化过程会尽可能地把花括号内的值当成是元素初始值的列表来处理， 只有在无法执行列表初始化时才会考虑其他初始化方式。** 在上例中， 给v2和v4提供的初始值都能作为元素的值，所以它们都会执行列表初始化， vector对象v2包含一个元素而vector对象v4包含两个元素。

**另一方面， 如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化， 就要考虑用这样的值来构造vector对象了。** 例如， 要想列表初始化一个含有string对象的vector对象， 应该提供能赋给string对象的初值。 此时不难区分到底是要列表初始化vector对象的元素还是用给定的容量值来构造vector对象：  

```c++
vector<string> v5{"hi"};			// 列表初始化：v5有一个元素
vector<string> v6("hi");			// 错误：不能使用字符串字面值构建vector对象
vector<string> v7{10};				// v7有10个默认初始化的元素
vector<string> v8{10, "hi"};		// v8有10个值为"hi"的元素
```

尽管在上面的例子中除了第二条语句之外都用了花括号， 但其实只有v5是列表初始化。 要想列表初始化vector对象， 花括号里的值必须与元素类型相同。 显然不能用int初始化string对象， 所以v7和v8提供的值不能作为元素的初始值。 确认无法执行列表初始化后， 编译器会尝试用默认值初始化vector对象。  



### 3.3.2 向vector对象中添加元素

对vector对象来说， 直接初始化的方式适用于三种情况： 初始值已知且数量较少、 初始值是另一个vector对象的副本、 所有元素的初始值都一样。 然而更常见的情况是： 创建一个vector对象时并不清楚实际所需的元素个数， 元素的值也经常无法确定。 还有些时候即使元素的初值已知， 但如果这些值总量较大而各不相同， 那么在创建vector对象的时候执行初始化操作也会显得过于烦琐。

举个例子， 如果想创建一个vector对象令其包含从0到9共10个元素， 使用列表初始化的方法很容易做到这一点； 但如果vector对象包含的元素是从0到99或者从0到999呢？ 这时通过列表初始化把所有元素都一一罗列出来就不太合适了。 **对于此例来说， 更好的处理方法是先创建一个空vector， 然后在运行时再利用vector的成员函数push_back向其中添加元素。 push_back负责把一个值当成vector对象的尾元素“压到（push） ”vector对象的“尾端（back） ”。** 例如：  

```c++
vector<int> v2;						// 空vector对象
for(int i = 0; i != 100; ++i)
	v2.push_back(i);				// 依次把整数值放到v2尾端
									// 循环结束后v2有100个元素，值从0到99
```

在上例中， 尽管知道vector对象最后会包含100个元素， 但在一开始还是把它声明成空vector， 在每次迭代时才顺序地把下一个整数作为v2的新元素添加给它。

同样的， 如果直到运行时才能知道vector对象中元素的确切个数，也应该使用刚刚这种方法创建vector对象并为其赋值。 例如， 有时需要实时读入数据然后将其赋予vector对象：  

```c++
//从标准输入中读取单词，将其作为vector对象的元素存储
string word;
vector<string> text;				// 空vector对象
while (cin >> word) {
	text.push_back(word);			// 把word添加到text后面
}
```

和之前的例子一样， 本例也是先创建一个空vector， 之后依次读入未知数量的值并保存到text中。



<u>关键概念： vector对象能高效增长</u>

<u>**C++标准要求vector应该能在运行时高效快速地添加元素。 因此既然vector对象能高效地增长， 那么在定义vector对象的时候设定其大小也就没什么必要了， 事实上如果这么做性能可能更差。 只有一种例外情况， 就是所有（all） 元素的值都一样。 一旦元素的值有所不同， 更有效的办法是先定义一个空的vector对象， 再在运行时向其中添加具体值。** 此外， 9.4节（第317页） 将介绍， vector还提供了方法， 允许我们进一步提升动态添加元素的性能。</u>  



#### 向vector对象添加元素蕴含的编程假定

由于能高效便捷地向vector对象中添加元素， 很多编程工作被极大简化了。 然而， 这种简便性也伴随着一些对编写程序更高的要求： 其中一条就是必须要确保所写的循环正确无误， 特别是在循环有可能改变vector对象容量的时候。

随着对vector的更多使用， 我们还会逐渐了解到其他一些隐含的要求， 其中一条是现在就要指出的： **如果循环体内部包含有向vector对象添加元素的语句， 则不能使用范围for循环**， 具体原因将在5.4.3节（第168页） 详细解释  

<u>**范围for语句体内不应改变其所遍历序列的大小。**</u>  



### 3.3.3 其他vector操作

除了push_back之外， vector还提供了几种其他操作， 大多数都和string的相关操作类似， 表3.5列出了其中比较重要的一些。  

![表3.5 vector支持的操作](C:\Users\Grey\Desktop\C++ Primer\图片\表3.5 vector支持的操作.png)

**访问vector对象中元素的方法和访问string对象中字符的方法差不多， 也是通过元素在vector对象中的位置。 例如， 可以使用范围for语句处理vector对象中的所有元素：**  

```c++
vector<int> v{1,2,3,4,5,6,7,8,9};
for (auto &i:v)				// 对于v中的每个元素（注意：1是一个引用）
	i *= i;					// 求元素值的平方
for (auto i:v)				// 对于V中的每个元素
	cout << i << " ";		// 输出该元素
cout << endl;
```

第一个循环把控制变量 i 定义成引用类型， 这样就能通过 i 给 v 的元素赋值， 其中 i 的类型由auto关键字指定。 这里用到了一种新的复合赋值运算符（参见1.4.1节， 第10页） 。 如我们所知， +=把左侧运算对象和右侧运算对象相加， 结果存入左侧运算对象； 类似的， *= 把左侧运算对象和右侧运算对象相乘， 结果存入左侧运算对象。 最后， 第二个循环输出所有元素。

vector的empty和size两个成员与string的同名成员（参见3.2.2节， 第78页） 功能完全一致： empty检查vector对象是否包含元素然后返回一个布尔值； size则返回vector对象中元素的个数， 返回值的类型是由vector定义的size_type类型。  

<u>要使用size_type， 需首先指定它是由哪种类型定义的。 vector对象的类型总是包含着元素的类型（参见3.3节， 第87页） ：</u>

```c++
vector<int>::size_type			// 正确
vector::size_type				// 错误
```

各个相等性运算符和关系运算符也与string的相应运算符（参见3.2.2节， 第79页） 功能一致。 两个vector对象相等当且仅当它们所含的元素个数相同， 而且对应位置的元素值也相同。 关系运算符依照字典顺序进行比较： 如果两个vector对象的容量不同， 但是在相同位置上的元素值都一样， 则元素较少的vector对象小于元素较多的vector对象； 若元素的值有区别， 则vector对象的大小关系由第一对相异的元素值的大小关系决定。

只有当元素的值可比较时， vector对象才能被比较。 一些类， 如string等， 确实定义了自己的相等性运算符和关系运算符； 另外一些，如Sales_item类支持的运算已经全都罗列在1.5.1节（第17页） 中了， 显然并不支持相等性判断和关系运算等操作。 因此， 不能比较两个vector<Sales_item>对象。



#### 计算vector内对象的索引

使用下标运算符（参见3.2.3节， 第84页） 能获取到指定的元素。 和string一样， vector对象的下标也是从0开始计起， 下标的类型是相应的size_type类型。 只要vector对象不是一个常量， 就能向下标运算符返回的元素赋值。 此外， 如3.2.3节（第85页） 所述的那样， 也能通过计算得到vector内对象的索引， 然后直接获取索引位置上的元素。

举个例子， 假设有一组成绩的集合， 其中成绩的取值是从0到100。以10分为一个分数段，要求统计各个分数段各有多少个成绩。 显然， 从0到100总共有101种可能的成绩取值， 这些成绩分布在11个分数段上：每10个分数构成一个分数段， 这样的分数段有10个， 额外还有一个分数段表示满分100分。 这样第一个分数段将统计成绩在0到9之间的数量； 第二个分数段将统计成绩在10到19之间的数量， 以此类推。 最后一个分数段统计满分100分的数量。

按照上面的描述， 如果输入的成绩如下：

`42 65 95 100 39 67 95 76 88 76 83 92 76 93`

则输出的结果应该是：

`0 0 0 1 1 0 2 3 2 4 1`

结果显示： 成绩在30分以下的没有、 30分至39分有1个、 40分至49分有1个、 50分至59分没有、 60分至69分有2个、 70分至79分有3个、 80分至89分有2个、 90分至99分有4个， 还有1个是满分。

在具体实现时使用一个含有11个元素的vector对象， 每个元素分别用于统计各个分数段上出现的成绩个数。 对于某个成绩来说， 将其除以10就能得到对应的分数段索引。 注意： 两个整数相除， 结果还是整数，余数部分被自动忽略掉了。 例如， 42/10=4、 65/10=6、 100/10=10等。 一旦计算得到了分数段索引， 就能用它作为vector对象的下标， 进而获取该分数段的计数值并加1：  

```c++
//以10分为一个分数段统计成绩的数量：0~9，10~19，90~99，100
vector<unsigned> scores(11,0);			// 11个分数段，全都初始化为0
unsigned grade;
while (cin >> grade){					// 读取成绩
	if (grade <= 100)					// 只处理有效的成绩
		++scores[grade / 10];			// 将对应分数段的计数值加1
}
```

在上面的程序中， 首先定义了一个vector对象存放各个分数段上成绩的数量。 此例中， 由于初始状态下每个元素的值都相同， 所以我们为vector对象申请了11个元素， 并把所有元素的初始值都设为0。 while语句的条件部分负责读入成绩， 在循环体内部首先检查读入的成绩是否合法（即是否小于等于100分） ， 如果合法， 将成绩对应的分数段的计数值加1。

执行计数值累加的那条语句很好地体现了C++程序代码的简洁性。表达式  

```c++
++scores[grade/10];						// 将当前分数段的计数值加1
```

等价于  

```c++
auto ind = grade/10;					// 得到分数段索引
scores[ind] = scores[ind] + 1;			// 将计数值加1
```

上述语句的含义是： 用grade除以10来计算成绩所在的分数段， 然后将所得的结果作为变量scores的下标。 通过运行下标运算获取该分数段对应的计数值， 因为新出现了一个属于该分数段的成绩， 所以将计数值加1。

如前所述， 使用下标的时候必须清楚地知道它是否在合理范围之内（参见3.2.3节， 第85页） 。 在这个程序里， 我们事先确认了输入的成绩确实在0到100之间， 这样计算所得的下标就一定在0到10之间， 属于0到scores.size() -1规定的有效范围， 一定是合法的。



#### 不能用下标形式添加元素

**刚接触C++语言的程序员也许会认为可以通过vector对象的下标形式来添加元素， 事实并非如此。** 下面的代码试图为vector对象ivec添加10个元素：  

```c++
vector<int>ivec;					// 空vector对象
for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)
	ivec[ix] = ix;					// 严重错误：ivec不包含任何元素
```

**然而， 这段代码是错误的： ivec是一个空vector， 根本不包含任何元素， 当然也就不能通过下标去访问任何元素！** 如前所述， 正确的方法是使用push_back：  

```c++
for (decltype(ivec.size()) ix = 0; ix != 10; ++ix)
	ivec.push_back(ix);				// 正确：添加一个新元素，该元素的值是ix
```

<u>**vector对象（以及string对象） 的下标运算符可用于访问已存在的元素， 而不能用于添加元素。**</u>  



<u>提示： 只能对确知已存在的元素执行下标操作！</u>

<u>**关于下标必须明确的一点是： 只能对确知已存在的元素执行下标操作。** 例如，</u>  

```c++
vector<int> ivec;				// 空vector对象
cout << ivec[0];				// 错误：ivec不包含任何元素
vector<int> ivec2(10);			// 含有10个元素的vector对象
cout << ivec2[10];				// 错误：ivec2元素的合法索引是从0到9
```

<u>试图用下标的形式去访问一个不存在的元素将引发错误， 不过这种错误不会被编译器发现， 而是在运行时产生一个不可预知的值。</u>

**<u>不幸的是， 这种通过下标访问不存在的元素的行为非常常见， 而且会产生很严重的后果。 所谓的缓冲区溢出（buffer overflow） 指的就是这类错误， 这也是导致PC及其他设备上应用程序出现安全问题的一个重要原因。</u>**

**<u>确保下标合法的一种有效手段就是尽可能使用范围for语句。</u>**  



## 3.4 迭代器介绍

我们已经知道可以使用下标运算符来访问string对象的字符或vector对象的元素，还有另外一种更通用的机制也可以实现同样的目的，这就是迭代器（iterator） 。在第II部分中将要介绍， 除了vector之外， 标准库还定义了其他几种容器。 所有标准库容器都可以使用迭代器， 但是其中只有少数几种才同时支持下标运算符。 严格来说， **string对象不属于容器类型， 但是string支持很多与容器类型类似的操作。** vector支持下标运算符， 这点和string一样； string支持迭代器， 这也和vector是一样的。

类似于指针类型（参见2.3.2节， 第47页） ， 迭代器也提供了对对象的间接访问。 就迭代器而言， 其对象是容器中的元素或者string对象中的字符。 使用迭代器可以访问某个元素， 迭代器也能从一个元素移动到另外一个元素。 迭代器有有效和无效之分， 这一点和指针差不多。 **有效的迭代器或者指向某个元素， 或者指向容器中尾元素的下一位置； 其他所有情况都属于无效。**



### 3.4.1 使用迭代器

**和指针不一样的是， 获取迭代器不是使用取地址符， 有迭代器的类型同时拥有返回迭代器的成员。** 比如， 这些类型都拥有名为begin和end的成员， 其中begin成员负责返回指向第一个元素（或第一个字符） 的迭代器。 如有下述语句：  

```c++
// 由编译器决定b和e的类型；参见2.5.2节（第61页)
// b表示v的第一个元素，e表示V尾元素的下一位置
auto b = v.begin(), e = v.end();			//b和e的类型相同
```

**end成员则负责返回指向容器（或string对象） “尾元素的下一位置（one past the end） ”的迭代器， 也就是说， 该迭代器指示的是容器的一个本不存在的“尾后（off the end） ”元素。 这样的迭代器没什么实际含义， 仅是个标记而已， 表示我们已经处理完了容器中的所有元素。 end成员返回的迭代器常被称作尾后迭代器（off-the-end iterator） 或者简称为尾迭代器（end iterator） 。 特殊情况下如果容器为空， 则begin和end返回的是同一个迭代器。**  



#### 迭代器运算符

表3.6列举了迭代器支持的一些运算。 使用 == 和 != 来比较两个合法的迭代器是否相等， 如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器， 则它们相等； 否则就说这两个迭代器不相等。  

![表3.6 标准容器迭代器的运算符](C:\Users\Grey\Desktop\C++ Primer\图片\表3.6 标准容器迭代器的运算符.png)

和指针类似， 也能通过解引用迭代器来获取它所指示的元素， 执行解引用的迭代器必须合法并确实指示着某个元素（参见2.3.2节， 第48页） 。**试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。**

举个例子，3.2.3节（第84页）中的程序利用下标运算符把string对象的第一个字母改为了大写形式， 下面利用迭代器实现同样的功能：

```c++
string s("some string");
if(s.begin() != s.end()){				 // 确保s非空
	auto it = s.begin()					// it表示s的第一个字符
	*it = toupper(*it);					// 将当前字符改成大写形式
}
```

本例和原来的程序一样， 首先检查s是否为空， 显然通过检查begin和end返回的结果是否一致就能做到这一点。 如果返回的结果一样， 说明s为空； 如果返回的结果不一样， 说明s不为空， 此时s中至少包含一个字符。

我们在if内部， 声明了一个迭代器变量it并把begin返回的结果赋给它， 这样就得到了指示s中第一个字符的迭代器， 接下来通过解引用运算符将第一个字符更改为大写形式。 和原来的程序一样， 输出结果将是：  

`Some string`  



#### 将迭代器从一个元素移动到另外一个元素

**迭代器使用递增（++） 运算符（参见1.4.1节， 第11页） 来从一个元素移动到下一个元素。 从逻辑上来说， 迭代器的递增和整数的递增类似， 整数的递增是在整数值上“加1”， 迭代器的递增则是将迭代器“向前移动一个位置”。**

之前有一个程序把string对象中第一个单词改写为大写形式， 现在利用迭代器及其递增运算符可以实现相同的功能：  

```c++
// 依次处理S的字符直至我们处理完全部字符或者遇到空白
for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it)
	*it = toupper(*it);				// 将当前字符改成大写形式
```

和3.2.3节（第84页） 的那个程序一样， 上面的循环也是遍历s的字符直到遇到空白字符为止， 只不过之前的程序用的是下标运算符， 现在这个程序用的是迭代器。

循环首先用s.begin的返回值来初始化it， 意味着it指示的是s中的第一个字符（如果有的话） 。条件部分检查是否已到达s的尾部， 如果尚未到达， 则将it解引用的结果传入isspace函数检查是否遇到了空白。 每次迭代的最后， 执行++it令迭代器前移一个位置以访问s的下一个字符。

循环体内部和上一个程序if语句内的最后一句话一样， 先解引用it，然后将结果传入toupper函数得到该字母对应的大写形式， 再把这个大写字母重新赋值给it所指示的字符。



<u>关键概念： 泛型编程</u>

<u>原来使用C或Java的程序员在转而使用C++语言之后， 会对for循环中使用 != 而非 < 进行判断有点奇怪， 比如上面的这个程序以及85页的那个。 **C++程序员习惯性地使用 !=， 其原因和他们更愿意使用迭代器而非下标的原因一样： 因为这种编程风格在标准库提供的所有容器上都有效。**</u>

<u>之前已经说过， 只有string和vector等一些标准库类型有下标运算符， 而并非全都如此。 与之类似， 所有标准库容器的迭代器都定义了 == 和 !=， 但是它们中的大多数都没有定义 < 运算符。 因此， **只要我们养成使用迭代器和 != 的习惯， 就不用太在意用的到底是哪种容器类型。**</u>  



#### 迭代器类型

就像不知道string和vector的size_type成员（参见3.2.2节， 第79页）到底是什么类型一样， 一般来说我们也不知道（其实是无须知道） 迭代器的精确类型。 而实际上， 那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型：

```c++
vector<int>::iterator it;			// it能读写vector<int>的元素
string::iterator it2;				// it2能读写string对象中的字符

vector<int>::const_iterator it3;	// it3只能读元素，不能写元素
string::const_iterator it4;			// 1t4只能读字符，不能写字符
```

const_iterator和常量指针（参见2.4.2节， 第56页） 差不多， 能读取但不能修改它所指的元素值。 相反， iterator的对象可读可写。 如果vector对象或string对象是一个常量， 只能使用const_iterator；如果vector对象或string对象不是常量，那么既能使用iterator也能使用const_iterator。  



<u>术语： 迭代器和迭代器类型</u>

<u>迭代器这个名词有三种不同的含义： 可能是迭代器概念本身， 也可能是指容器定义的迭代器类型， 还可能是指某个迭代器对象。</u>

<u>重点是理解存在一组概念上相关的类型， 我们认定某个类型是迭代器当且仅当它支持一套操作， 这套操作使得我们能访问容器的元素或者从某个元素移动到另外一个元素。</u>

<u>每个容器类定义了一个名为iterator的类型， 该类型支持迭代器概念所规定的一套操作。</u>  



#### begin和end运算符

**begin和end返回的具体类型由对象是否是常量决定， 如果对象是常量， begin和end返回const_iterator； 如果对象不是常量， 返回iterator：**  

```c++
vector<int> v;
const vector<int> cv;

auto it1 = v.begin();		// it1的类型是vector<int>::iterator
auto it2 = cv.begin();		// it2的类型是vector<int>::const iterator
```

有时候这种默认的行为并非我们所要。 在6.2.3节（第191页） 中将会看到， 如果对象只需读操作而无须写操作的话最好使用常量类型(比如 const_iterator ) 。为了便于专门得到const_iterator类型的返回值

```c++
auto it3 = v.cbegin();		// it3的类型是vector<int>::const_iterator
```

**C++11新标准引入了两个新函数， 分别是cbegin和cend**：类似于begin和end， 上述两个新函数也分别返回指示容器第一个元素或最后元素下一位置的迭代器。 有所不同的是， **不论vector对象（或string对象） 本身是否是常量， 返回值都是const_iterator。**  



#### 结合解引用和成员访问操作

解引用迭代器可获得迭代器所指的对象， 如果该对象的类型恰好是类， 就有可能希望进一步访问它的成员。 例如， 对于一个由字符串组成的vector对象来说， 要想检查其元素是否为空， 令 it 是该vector对象的迭代器， 只需检查 it 所指字符串是否为空就可以了， 其代码如下所示：

```c++
(*it).empty()
```

注意， （*it).empty() 中的圆括号必不可少， 具体原因将在4.1.2节（第121页） 介绍， 该表达式的含义是先对 it 解引用， 然后解引用的结果再执行点运算符（参见1.5.2节， 第20页） 。 如果不加圆括号，点运算符将由it来执行， 而非it解引用的结果：  

```c++
(*it).empty()	// 解引用it,然后调用结果对象的empty成员
*it.empty()		// 错误：试图访问it的名为empty的成员，但it是个迭代器，没有empty成员
```

上面第二个表达式的含义是从名为 it 的对象中寻找其empty成员， 显然it是一个迭代器， 它没有哪个成员是叫empty的， 所以第二个表达式将发生错误。

为了简化上述表达式， C++语言定义了箭头运算符(->) 。 箭头运算符把解引用和成员访问两个操作结合在一起， 也就是说， it->mem和(*it).mem表达的意思相同。

例如， 假设用一个名为text的字符串向量存放文本文件中的数据，其中的元素或者是一句话或者是一个用于表示段落分隔的空字符串。 如果要输出text中第一段的内容， 可以利用迭代器写一个循环令其遍历text， 直到遇到空字符串的元素为止：  

```c++
//依次输出text的每一行直至遇到第一个空白行为止
for (auto it = text.cbegin(); it != text.cend() && !it->empty(); ++it)
	cout << *it << endl;
```



#### 某些对vector对象的操作会使迭代器失效

3.3.2节（第90页） 曾经介绍过， **虽然vector对象可以动态地增长，但是也会有一些副作用。 已知的一个限制是不能在范围for循环中向vector对象添加元素。 另外一个限制是任何一种可能改变vector对象容量的操作， 比如push_back， 都会使该vector对象的迭代器失效。** 9.3.6节（ 第315页） 将详细解释迭代器是如何失效的。



### 3.4.2 迭代器运算

迭代器的递增运算令迭代器每次移动一个元素， **所有的标准库容器都有支持递增运算的迭代器。 类似的， 也能用 == 和 != 对任意标准库类型的两个有效迭代器（ 参见3.4节， 第95页） 进行比较。**

string和vector的迭代器提供了更多额外的运算符，一方面可使得迭代器的每次移动跨过多个元素，另外也支持迭代器进行关系运算。 所有这些运算被称作迭代器运算( iterator arithmetic ) ， 其细节由表3.7列出。  

![表3.7 vector和string迭代器支持的运算](C:\Users\Grey\Desktop\C++ Primer\图片\表3.7 vector和string迭代器支持的运算.png)



#### 迭代器的算术运算

可以令迭代器和一个整数值相加（或相减） ， 其返回值是向前（或向后） 移动了若干个位置的迭代器。 执行这样的操作时， 结果迭代器或者指示原vector对象（或string对象） 内的一个元素， 或者指示原vector对象（或string对象）尾元素的下一位置。 举个例子， 下面的代码得到一个迭代器， 它指向某vector对象中间位置的元素：  

```c++
//计算得到最接近ⅴi中间元素的一个迭代器
auto mid = vi.begin() + vi.size() / 2;
```

如果vi有20个元素， vi.size() / 2 得10， 此例中即令mid等于vi.begin() +10。 已知下标从0开始， 则迭代器所指的元素是vi[10]， 也就是从首元素开始向前相隔10个位置的那个元素。

对于string或vector的迭代器来说， 除了判断是否相等， 还能使用关系运算符（<、 <=、 >、 >=） 对其进行比较。 参与比较的两个迭代器必须合法而且指向的是同一个容器的元素（或者尾元素的下一位置） 。 例如， 假设it和mid是同一个vector对象的两个迭代器， 可以用下面的代码来比较它们所指的位置孰前孰后：

```c++
if(it < mid)				// 处理vi前半部分的元素
```

只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置， 就能将其相减， 所得结果是**两个迭代器的距离。 所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type的带符号整型数。**string和vector都定义了difference_type， 因为这个距离可正可负， 所以difference_type是带符号类型的。  



#### 使用迭代器运算

使用迭代器运算的一个经典算法是二分搜索。 二分搜索从有序序列中寻找某个给定的值。 二分搜索从序列中间的位置开始搜索， 如果中间位置的元素正好就是要找的元素， 搜索完成； 如果不是， 假如该元素小于要找的元素， 则在序列的后半部分继续搜素； 假如该元素大于要找的元素， 则在序列的前半部分继续搜索。 在缩小的范围中计算一个新的中间元素并重复之前的过程， 直至最终找到目标或者没有元素可供继续搜索。

下面的程序使用迭代器完成了二分搜索：  

```c++
// text必须是有序的
// beg和end表示我们搜索的范围
auto beg = text.begin(), end = text.end();
auto mid = text.begin() + (end - beg) / 2;		// 初始状态下的中间点
// 当还有元素尚未检查并且我们还没有找到sought时执行循环
while (mid != end && *mid != sought){
	if (sought < *mid)				// 我们要找的元素在前半部分吗？
		end = mid;					//如果是，调整搜索范围使得忽略掉后半部分
	else							//我们要找的元素在后半部分
		beg = mid + 1;				//在mid之后寻找
	mid = beg + (end - beg) / 2;	//新的中间点
}
```

程序的一开始定义了三个迭代器： beg指向搜索范围内的第一个元素、 end指向尾元素的下一位置、 mid指向中间的那个元素。 初始状态下， 搜索范围是名为text的vector<string>的全部范围。

循环部分先检查搜索范围是否为空， 如果mid和end的当前值相等，说明已经找遍了所有元素。 此时条件不满足， 循环终止。 当搜索范围不为空时， 可知mid指向了某个元素， 检查该元素是否就是我们所要搜索的， 如果是， 也终止循环。

当进入到循环体内部后， 程序通过某种规则移动beg或者end来缩小搜索的范围。 如果mid所指的元素比要找的元素sought大， 可推测若text含有sought， 则必出现在mid所指元素的前面。 此时，可以忽略mid后面的元素不再查找，并把mid赋给end即可。另一种情况， 如果*mid比sought小， 则要找的元素必出现在mid所指元素的后面。 此时， 通过令beg指向mid的下一个位置即可改变搜索范围。 因为已经验证过mid不是我们要找的对象， 所以在接下来的搜索中不必考虑它。

循环过程终止时， mid或者等于end或者指向要找的元素。 如果mid等于end， 说明text中没有我们要找的元素。  



## 3.5 数组

数组是一种类似于标准库类型vector（参见3.3节， 第86页） 的数据结构， 但是在性能和灵活性的权衡上又与vector有所不同。 与vector相似的地方是， 数组也是存放类型相同的对象的容器， 这些对象本身没有名字，需要通过其所在位置访问。与vector不同的地方是，数组的大小确定不变， 不能随意向数组中增加元素。 因为数组的大小固定， 因此对某些特殊的应用来说程序的运行时性能较好， 但是相应地也损失了一些灵活性。

<u>如果不清楚元素的确切个数， 请使用vector。</u>



### 3.5.1 定义和初始化内置数组

数组是一种复合类型（参见2.3节， 第45页） 。数组的声明形如a[d]， 其中a是数组的名字， d是数组的维度。 维度说明了数组中元素的个数， 因此必须大于0。 **数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。 也就是说， 维度必须是一个常量表达式**（参见2.4.4节， 第58页） ：  

```c++
unsigned cnt = 42;				// 不是常量表达式
constexpr unsigned sz = 42;		// 常量表达式
int arr[10];					// 含有10个整数的数组
int *parr[sz];					// 含有42个整型指针的数组
string bad[cnt];				// 错误：cnt不是常量表达式
string strs[get_size()];		// 当get_size是constexpr时正确；否则错误
```

默认情况下， 数组的元素被默认初始化  

<u>**和内置类型的变量一样， 如果在函数内部定义了某种内置类型的数组， 那么默认初始化会令数组含有未定义的值。**</u>

**定义数组的时候必须指定数组的类型， 不允许用auto关键字由初始值的列表推断类型。 另外和vector一样， 数组的元素应为对象， 因此不存在引用的数组。**  



#### 显式初始化数组元素

可以对数组的元素进行列表初始化（参见3.3.1节， 第88页） ， 此时允许忽略数组的维度。 如果在声明时没有指明维度， 编译器会根据初始值的数量计算并推测出来； 相反， 如果指明了维度， 那么初始值的总数量不应该超出指定的大小。 如果维度比提供的初始值数量大， 则用提供的初始值初始化靠前的元素， 剩下的元素被初始化成默认值（参见3.3.1节， 第88页） ：  

```c++
const unsigned sz = 3;
int ia1[sz] = {0, 1, 2};			// 含有3个元素的数组，元素值分别是0,1,2
int a2[] = {0, 1, 2};				// 维度是3的数组
int a3[5] = {0, 1, 2};				// 等价于a3[] = {0,1,2,0,0}
string a4[3]{"hi", "bye"};			// 等价于a4[] = {"hi","bye",""}
int a5[2] = {0, 1, 2};				// 错误：初始值过多
```



#### 字符数组的特殊性

字符数组有一种额外的初始化形式， 我们可以用字符串字面值（参见2.1.3节， 第36页） 对此类数组初始化。 当使用这种方式时， 一定要注意字符串字面值的结尾处还有一个空字符， 这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去：

```c++
char a1[] = {'','+','+'};			// 列表初始化，没有空字符
char a2[] = {'C','+','+','\0'};		// 列表初始化，含有显式的空字符
char a3[] = "C++";					// 自动添加表示字符串结束的空字符
const char a4[6] = "Daniel";		// 错误：没有空间可存放空字符！
```

a1的维度是3， a2和a3的维度都是4， a4的定义是错误的。 尽管字符串字面值"Daniel"看起来只有6个字符， 但是数组的大小必须至少是7，其中6个位置存放字面值的内容， 另外1个存放结尾处的空字符。



#### 不允许拷贝和赋值  

**不能将数组的内容拷贝给其他数组作为其初始值， 也不能用数组为其他数组赋值**  

```c++
inta[] = {0, 1, 2};				  // 含有3个整数的数组
int a2[] = a;			  		 // 错误：不允许使用一个数组初始化另一个数组
a2 = a;							// 错误：不能把一个数组直接赋值给另一个数组
```



#### 理解复杂的数组声明

和vector一样， 数组能存放大多数类型的对象。 例如， 可以定义一个存放指针的数组。 又因为数组本身就是对象， 所以允许定义数组的指针及数组的引用。 在这几种情况中， 定义存放指针的数组比较简单和直接， 但是定义数组的指针或数组的引用就稍微复杂一点了：

```c++
int *ptrs[10];					// ptrs是含有10个整型指针的数组
int &refs[10] = /* ? */;		// 错误：不存在引用的数组
int (*Parray)[10] = &arr;		// Parray指向一个含有l0个整数的数组
int (&arrRef)[10] = arr;		// arrRef引用一个含有10个整数的数组
```

默认情况下， 类型修饰符从右向左依次绑定。 对于ptrs来说， 从右向左（参见2.3.3节， 第52页） 理解其含义比较简单： 首先知道我们定义的是一个大小为10的数组， 它的名字是ptrs， 然后知道数组中存放的是指向int的指针。

但是对于Parray来说， 从右向左理解就不太合理了。 因为数组的维度是紧跟着被声明的名字的， 所以就数组而言， 由内向外阅读要比从右向左好多了。 由内向外的顺序可帮助我们更好地理解Parray的含义： 首先是圆括号括起来的部分,  *Parray意味着Parray是个指针， 接下来观察右边， 可知道Parray是个指向大小为10的数组的指针， 最后观察左边， 知道数组中的元素是int。 这样最终的含义就明白无误了， Parray是一个指针， 它指向一个int数组， 数组中包含10个元素。**同理, （&arrRef） 表示arrRef是一个引用， 它引用的对象是一个大小为10的数组， 数组中元素的类型是int。**

**当然， 对修饰符的数量并没有特殊限制：**

```c++
int* (&arry)[10] = ptrs;		// arry是数组的引用，该数组含有10个指针
```

**按照由内向外的顺序阅读上述语句， 首先知道arry是一个引用， 然后观察右边知道， arry引用的对象是一个大小为10的数组， 最后观察左边知道， 数组的元素类型是指向int的指针。 这样， arry就是一个含有10个int型指针的数组的引用。**



### 3.5.2 访问数组元素

与标准库类型vector和string一样， 数组的元素也能使用范围for语句或下标运算符来访问。 数组的索引从0开始， 以一个包含10个元素的数组为例， 它的索引从0到9， 而非从1到10。

**在使用数组下标的时候， 通常将其定义为size_t类型。 size_t是一种机器相关的无符号类型， 它被设计得足够大以便能表示内存中任意对象的大小。 在cstddef头文件中定义了size_t类型， 这个文件是C标准库stddef.h头文件的C++语言版本。**

数组除了大小固定这一特点外， 其他用法与vector基本类似。 例如， 可以用数组来记录各分数段的成绩个数， 从而实现与3.3.3节（第93页） 的程序一样的功能：

```c++
// 以10分为一个分数段统计成绩的数量：0~9,10~19，.，90~99,100
unsigned scores[11] = {};			// 11个分数段，全部初始化为0
unsigned grade;
while (cin >> grade){
	if (grade < 100)
		++scores[grade/10];			// 将当前分数段的计数值加1
}
```

与93页的程序相比， 上面程序最大的不同是scores的声明。 这里scores是一个含有11个无符号元素的数组。 另外一处不太明显的区别是， **本例所用的下标运算符是由C++语言直接定义的， 这个运算符能用在数组类型的运算对象上。 93页的那个程序所用的下标运算符是库模板vector定义的， 只能用于vector类型的运算对象。**  

与vector和string一样， 当需要遍历数组的所有元素时， 最好的办法也是使用范围for语句。 例如， 下面的程序输出所有的scores：

```c++
for (auto i : scores)			// 对于scores中的每个计数值
	cout << i << " ";			// 输出当前的计数值
cout << endl;
```

因为维度是数组类型的一部分， 所以系统知道数组scores中有多少个元素， 使用范围for语句可以减轻人为控制遍历过程的负担。



#### 检查下标的值

与vector和string一样，数组的下标是否在合理范围之内由程序员负责检查， 所谓合理就是说下标应该大于等于0而且小于数组的大小。要想防止数组下标越界， 除了小心谨慎注意细节以及对代码进行彻底的测试之外， 没有其他好办法。 对于一个程序来说， 即使顺利通过编译并执行， 也不能肯定它不包含此类致命的错误。  



### 3.5.3 指针和数组

在C++语言中，指针和数组有非常紧密的联系。 就如即将介绍的，使用数组的时候编译器一般会把它转换成指针。通常情况下， 使用取地址符（参见2.3.2节， 第47页） 来获取指向某个对象的指针， 取地址符可以用于任何对象。 数组的元素也是对象， 对数组使用下标运算符得到该数组指定位置的元素。 因此像其他对象一样， 对数组的元素使用取地址符就能得到指向该元素的指针：  

```c++
string nums[] = {"one","two","three"};		// 数组的元素是string对象
string *p = &nums[0];						// p指向nums的第一个元素
```

**然而， 数组还有一个特性： 在很多用到数组名字的地方， 编译器都会自动地将其替换为一个指向数组首元素的指针：**

```c++
string *p2 = nums;							// 等价于p2 = &nums[0]
```

<u>在大多数表达式中， 使用数组类型的对象其实是使用一个指向该数组首元素的指针。</u>  

由上可知， 在一些情况下数组的操作实际上是指针的操作， 这一结论有很多隐含的意思。 其中一层意思是**当使用数组作为一个auto（参见2.5.2节， 第61页） 变量的初始值时， 推断得到的类型是指针而非数组：**

```c++
int ia[] = {0,1,2,3,4,5,6,7,8,9};	  // ia是一个含有10个整数的数组
auto ia2(ia);						// ia2是一个整型指针，指向ia的第一个元素
ia2 = 42;							// 错误：ia2是一个指针，不能用int值给指针赋值
```

尽管ia是由10个整数构成的数组， 但当使用ia作为初始值时， 编译器实际执行的初始化过程类似于下面的形式：

```c++
auto ia2(&ia[0]);					// 显然ia2的类型是int*
```

**必须指出的是， 当使用decltype关键字（参见2.5.3节， 第62页）时上述转换不会发生， decltype(ia)返回的类型是由10个整数构成的数组：**  

```c++
// ia3是一个含有10个整数的数组
dec1type(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};
ia3 = p;							// 错误：不能用整型指针给数组赋值
ia3[4] = i;							// 正确：把i的值赋给ia3的一个元素
```

> **auto数组名是指针，decltype数组名还是数组**



#### 指针也是迭代器

与2.3.2节（第47页）介绍的内容相比， 指向数组元素的指针拥有更多功能。 **vector和string的迭代器（参见3.4节， 第95页） 支持的运算， 数组的指针全都支持。** 例如， 允许使用递增运算符将指向数组元素的指针向前移动到下一个位置上：

```c++
int arr[] = {0,1,2,3,4,5,6,7,8,9};
int *p = arr;						// p指向arr的第一个元素
++p;   								// p指向arr[1]
```

就像使用迭代器遍历vector对象中的元素一样， 使用指针也能遍历数组中的元素。 当然， 这样做的前提是先得获取到指向数组第一个元素的指针和指向数组尾元素的下一位置的指针。 之前已经介绍过， 通过数组名字或者数组中首元素的地址都能得到指向首元素的指针； 不过获取尾后指针就要用到数组的另外一个特殊性质了。 我们可以设法获取数组尾元素之后的那个并不存在的元素的地址：

```c++
int *e = &arr[10];					// 指向arr尾元素的下一位置的指针
```

**这里显然使用下标运算符索引了一个不存在的元素， arr有10个元素， 尾元素所在位置的索引是9， 接下来那个不存在的元素唯一的用处就是提供其地址用于初始化e。 就像尾后迭代器（参见3.4.1节， 第95页） 一样， 尾后指针也不指向具体的元素。 因此， 不能对尾后指针执行解引用或递增的操作。**

利用上面得到的指针能重写之前的循环， 令其输出arr的全部元素：  

```c++
for(int *b = arr; b != e; ++b)
	cout << *b << endl;				// 输出arr的元素
```



#### 标准库函数begin和end

尽管能计算得到尾后指针， 但这种用法极易出错。 为了让指针的使用更简单、 更安全， **C++11新标准引入了两个名为begin和end的函数 *(标准名字空间内)* 。**这两个函数与容器中的两个同名成员（参见3.4.1节， 第95页） 功能类似， 不过数组毕竟不是类类型， 因此这两个函数不是成员函数。 正确的使用形式是将数组作为它们的参数：

```c++
int ia[] = {0,1,2,3,4,5,6,7,8,9};	// ia是一个含有10个整数的数组
int *beg = begin(ia);				// 指向ia首元素的指针
int *last = end(ia);				// 指向arr尾元素的下一位置的指针
```

begin函数返回指向ia首元素的指针， end函数返回指向ia尾元素下一位置的指针， **这两个函数定义在iterator头文件中。**

使用begin和end可以很容易地写出一个循环并处理数组中的元素。例如， 假设arr是一个整型数组， 下面的程序负责找到arr中的第一个负数  

```c++
// pbeg指向arr的首元素，pend指向arr尾元素的下一位置
int *pbeg = begin(arr), *pend = end(arr);
// 寻找第一个负值元素，如果已经检查完全部元素则结束循环
while (pbeg != pend && *pbeg >= 0 )
	++pbeg;
```

首先定义了两个名为pbeg和pend的整型指针， 其中pbeg指向arr的第一个元素， pend指向arr尾元素的下一位置。 while语句的条件部分通过比较pbeg和pend来确保可以安全地对pbeg解引用， 如果pbeg确实指向了一个元素， 将其解引用并检查元素值是否为负值。 如果是， 条件失效、退出循环； 如果不是， 将指针向前移动一位继续考查下一个元素。



#### 指针运算

**指向数组元素的指针可以执行表3.6（第96页） 和表3.7（第99页）列出的所有迭代器运算。** 这些运算， 包括解引用、 递增、 比较、 与整数相加、 两个指针相减等， 用在指针和用在迭代器上意义完全一致。

给（从） 一个指针加上（减去） 某整数值， 结果仍是指针。 新指针指向的元素与原来的指针相比前进了（后退了） 该整数值个位置：

```c++
constexpr size_t sz = 5;
int arr[sz] = {1,2,3,4,5}:
int *ip = arr;						// 等价于int* ip = &arr[0]
int* ip2 = ip + 4;					// ip2指向arr的尾元素arr[4]
```

ip加上4所得的结果仍是一个指针， 该指针所指的元素与ip原来所指的元素相比前进了4个位置。  

**给指针加上一个整数， 得到的新指针仍需指向同一数组的其他元素， 或者指向同一数组的尾元素的下一位置：**  

```c++
// 正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置
int *p = arr + sz;					// 使用警告：不要解引用！
int *p2 = arr + 10;					// 错误：arr只有5个元素，p2的值未定义
```

当给arr加上sz时， 编译器自动地将arr转换成指向数组arr中首元素的指针。 执行加法后， 指针从首元素开始向前移动了sz（这里是5） 个位置， 指向新位置的元素。 也就是说， 它指向了数组arr尾元素的下一位置。 如果计算所得的指针超出了上述范围就将产生错误， 而且这种错误编译器一般发现不了。

**和迭代器一样， 两个指针相减的结果是它们之间的距离。 参与运算的两个指针必须指向同一个数组当中的元素：**

```c++
auto n = end(arr) - begin(arr);		// n的值是5，也就是arr中元素的数量
```

**两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型**， 和size_t一样， ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型。 **因为差值可能为负值， 所以ptrdiff_t是一种带符号类型。**

**只要两个指针指向同一个数组的元素， 或者指向该数组的尾元素的下一位置， 就能利用关系运算符对其进行比较**。 例如， 可以按照如下的方式遍历数组中的元素  

```c++
int *b = arr, *e = arr + sz;
while (b < e){
	// 使用*b
	++b;
}
```

**如果两个指针分别指向不相关的对象， 则不能比较它们：**  

```c++
int i = 0, sz = 42;
int *p  = &i, *e = &sz;
// 未定义的：p和e无关，因此比较毫无意义！
while (p < e)
```

尽管作用可能不是特别明显， 但必须说明的是， **上述指针运算同样适用于空指针（参见2.3.2节， 第48页） 和所指对象并非数组的指针。** 在后一种情况下， 两个指针必须指向同一个对象或该对象的下一位置。 如果p是空指针， 允许给p加上或减去一个值为0的整型常量表达式（参见2.4.4节， 第58页） 。 两个空指针也允许彼此相减， 结果当然是0。



#### 解引用和指针运算的交互

指针加上一个整数所得的结果还是一个指针。 假设结果指针指向了一个元素， 则允许解引用该结果指针：  

```c++
int ia[] = {0,2,4,6,8};			// 含有5个整数的数组
int last = *(ia + 4);			// 正确：把1ast初始化成8，也就是ia[4]的值
```

表达式 *(ia+4)  计算ia前进4个元素后的新地址， 解引用该结果指针的效果等价于表达式ia[4]。

回忆一下在3.4.1节（第98页） 中介绍过如果表达式含有解引用运算符和点运算符， 最好在必要的地方加上圆括号。 类似的， 此例中指针加法的圆括号也不可缺少。 如果写成下面的形式：

```c++
1ast = *ia + 4;					// 正确：1ast = 4等价于ia[0] + 4
```

含义就与之前完全不同了， 此时先解引用ia， 然后给解引用的结果再加上4。  



#### 下标和指针

如前所述， 在很多情况下使用数组的名字其实用的是一个指向数组首元素的指针。 一个典型的例子是当对数组使用下标运算符时， 编译器会自动执行上述转换操作。 给定

```c++
int ia[] = {0,2,4,6,8};			// 含有5个整数的数组
```

此时， **ia[0]是一个使用了数组名字的表达式， 对数组执行下标运算其实是对指向数组元素的指针执行下标运算：**  

```c++
int i = ia[2];					// ia转换成指向数组首元素的指针
								// ia[2]得到(ia+2)所指的元素
int *p = ia;					// p指向ia的首元素
i = *(p + 2):					// 等价于i = ia[2]
```

只要指针指向的是数组中的元素 ( 或者数组中尾元素的下一位置 ) , 都可以执行下标运算：

```c++
int *p = &ia[2];				// p指向索引为2的元素
int j = p[1];					// p[1]等价于*(p+1),就是ia[3]表示的那个元素
int k = p[-2];					// p[-2]是ia[0]表示的那个元素
```

**虽然标准库类型string和vector也能执行下标运算， 但是数组与它们相比还是有所不同。 标准库类型限定使用的下标必须是无符号类型， 而内置的下标运算无此要求**， 上面的最后一个例子很好地说明了这一点。**内置的下标运算符可以处理负值， 当然， 结果地址必须指向原来的指针所指同一数组中的元素（或是同一数组尾元素的下一位置） 。**

<u>**内置的下标运算符所用的索引值不是无符号类型， 这一点与vector和string不一样。**</u>  



### 3.5.4 C风格字符串

字符串字面值是一种通用结构的实例， 这种结构即是C++由C继承而来的C风格字符串（C-style character string） 。 C风格字符串不是一种类型， 而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束( null terminated ) 。 以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（'\0'）。一般利用指针来操作这些字符串



#### C标准库String函数

表3.8列举了C语言标准库提供的一组函数， 这些函数可用于操作C风格字符串， 它们定义在cstring头文件中， cstring是C语言头文件string.h的C++版本。  

![表3.8 C风格字符串的函数](C:\Users\Grey\Desktop\C++ Primer\图片\表3.8 C风格字符串的函数.png)

传入此类函数的指针必须指向以空字符作为结束的数组：

```c++
char ca[] = {'C','+','+'};			// 不以空字符结束
cout << strlen(ca) << endl;			// 严重错误：ca没有以空字符结束
```

此例中， ca虽然也是一个字符数组但它不是以空字符作为结束的，因此上述程序将产生未定义的结果。 strlen函数将有可能沿着ca在内存中的位置不断向前寻找， 直到遇到空字符才停下来。



#### 比较字符串

比较两个C风格字符串的方法和之前学习过的比较标准库string对象的方法大相径庭。 比较标准库string对象的时候， 用的是普通的关系运算符和相等性运算符：  

```c++
string s1 = "A string example";
string s2 = "A different string";
if(s1 < s2)							// fa1se：s2小于s1
```

如果把这些运算符用在两个C风格字符串上， 实际比较的将是指针而非字符串本身：

```c++
const char cal[] =  "A string example";
const char ca2[] =  "A different string";
if (ca1 < ca2)						// 未定义的：试图比较两个无关地址
```

谨记之前介绍过的， 当使用数组的时候其实真正用的是指向数组首元素的指针（参见3.5.3节， 第105页） 。 因此， 上面的if条件实际上比较的是两个const char＊ 的值。 这两个指针指向的并非同一对象， 所以将得到未定义的结果。

要想比较两个C风格字符串需要调用strcmp函数，此时比较的就不再是指针了。 如果两个字符串相等， strcmp返回0； 如果前面的字符串较大， 返回正值； 如果后面的字符串较大， 返回负值：  

```c++
if(strcmp(ca1, ca2) < 0))			// 和两个string对象的比较s1 < s2效果一样
```



#### 目标字符串的大小由调用者指定

连接或拷贝C风格字符串也与标准库string对象的同类操作差别很大。 例如， 要想把刚刚定义的那两个string对象s1和s2连接起来， 可以直接写成下面的形式：

```c++
// 将largeStr初始化成s1、一个空格和s2的连接
string largestr = s1 + " " + s2;
```

同样的操作如果放到ca1和ca2这两个数组身上就会产生错误了。 表达式ca1 + ca2试图将两个指针相加， 显然这样的操作没什么意义， 也肯定是非法的。

正确的方法是使用strcat函数和strcpy函数。 不过要想使用这两个函数， 还必须提供一个用于存放结果字符串的数组， 该数组必须足够大以便容纳下结果字符串及末尾的空字符。 下面的代码虽然很常见， 但是充满了安全风险， 极易引发严重错误：  

```c++
// 如果我们计算错了1 argeStr的大小将引发严重错误
strcpy(largestr,ca1);				// 把ca1拷贝给largeStr
strcat(largestr," ")				// 在largeStr的末尾加上一个空格
strcat(largestr,ca2);				// 把ca2连接到largestr后面
```

一个潜在的问题是，我们在估算largeStr所需的空间时不容易估准，而且largeStr所存的内容一旦改变， 就必须重新检查其空间是否足够。 不幸的是， 这样的代码到处都是， 程序员根本没法照顾周全。 这类代码充满了风险而且经常导致严重的安全泄漏。

<u>对大多数应用来说， 使用标准库string要比使用C风格字符串更安全、 更高效。</u>  



## 3.6 多维数组

严格来说， C++语言中没有多维数组， 通常所说的**多维数组其实是数组的数组。** 谨记这一点， 对今后理解和使用多维数组大有益处。

当一个数组的元素仍然是数组时， 通常使用两个维度来定义它： 一个维度表示数组本身大小， 另外一个维度表示其元素（也是数组） 大小：

```c++
int ia[3][4];				// 大小为3的数组，每个元素是含有4个整数的数组
// 大小为10的数组，它的每个元素都是大小为20的数组，
// 这些数组的元素是含有30个整数的数组
int arr[10][20][30] = {0};			// 将所有元素初始化为0
```

如3.5.1节（第103页） 所介绍的， 按照由内而外的顺序阅读此类定义有助于更好地理解其真实含义。 在第一条语句中， 我们定义的名字是ia， 显然ia是一个含有3个元素的数组。 接着观察右边发现， ia的元素也有自己的维度， 所以ia的元素本身又都是含有4个元素的数组。 再观察左边知道， 真正存储的元素是整数。 因此最后可以明确第一条语句的含义： 它定义了一个大小为3的数组， 该数组的每个元素都是含有4个整数的数组。

使用同样的方式理解arr的定义。 首先arr是一个大小为10的数组，它的每个元素都是大小为20的数组， 这些数组的元素又都是含有30个整数的数组。 实际上， 定义数组时对下标运算符的数量并没有限制， 因此只要愿意就可以定义这样一个数组： 它的元素还是数组， 下一级数组的元素还是数组， 再下一级数组的元素还是数组， 以此类推。

对于二维数组来说， 常把第一个维度称作行， 第二个维度称作列。



#### 多维数组的初始化

允许使用花括号括起来的一组值初始化多维数组， 这点和普通的数组一样。 下面的初始化形式中， 多维数组的每一行分别用花括号括了起来：  

```c++
int ia[3][4] = {			// 三个元素，每个元素都是大小为4的数组
	{0,1,2,3},				// 第1行的初始值
	{4,5,6,7},				// 第2行的初始值
	{8,9,10,11}				// 第3行的初始值
}；
```

其中内层嵌套着的花括号并非必需的， 例如下面的初始化语句， 形式上更为简洁， 完成的功能和上面这段代码完全一样：  

```c++
// 没有标识每行的花括号，与之前的初始化语句是等价的
int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
```

类似于一维数组， 在初始化多维数组时也并非所有元素的值都必须包含在初始化列表之内。 如果仅仅想初始化每一行的第一个元素， 通过如下的语句即可：

```c++
// 显式地初始化每行的首元素
int ia[3][4] = {{0},{4},{8}}:
```

其他未列出的元素执行默认值初始化， 这个过程和一维数组（参见3.5.1节， 第102页） 一样。 在这种情况下如果再省略掉内层的花括号，结果就大不一样了。 下面的代码

```c++
// 显式地初始化第1行，其他元素执行值初始化
int ia[3][4] = {0,3,6,9};
```

含义发生了变化， 它初始化的是第一行的4个元素， 其他元素被初始化为0。  



#### 多维数组的下标引用

可以使用下标运算符来访问多维数组的元素， 此时数组的每个维度对应一个下标运算符。

如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素； 反之， 如果表达式含有的下标运算符数量比数组的维度小， 则表达式的结果将是给定索引处的一个内层数组：

```c++
// 用arr的首元素为ia最后一行的最后一个元素赋值
ia[2][3] = arr[0][0][0];
int(&row)[4] = ia[1];		// 把row绑定到1a的第二个4元素数组上
```

在第一个例子中， 对于用到的两个数组来说， 表达式提供的下标运算符数量都和它们各自的维度相同。 在等号左侧， ia[2]得到数组ia的最后一行， 此时返回的是表示ia最后一行的那个一维数组而非任何实际元素； 对这个一维数组再取下标， 得到编号为[3]的元素， 也就是这一行的最后一个元素。

类似的， 等号右侧的运算对象包含3个维度。 首先通过索引0得到最外层的数组， 它是一个大小为20的（多维） 数组； 接着获取这20个元素数组的第一个元素， 得到一个大小为30的一维数组； 最后再取出其中的第一个元素。

在第二个例子中， 把row定义成一个含有4个整数的数组的引用， 然后将其绑定到ia的第2行。

再举一个例子， 程序中经常会用到两层嵌套的for循环来处理多维数组的元素：  

```c++
constexpr size_t rowCnt = 3, colCnt = 4;

int ia[rowCnt][colCnt];				// 12个未初始化的元素
// 对于每一行
for (size_t i = 0; i != rowCnt; ++i) {
	// 对于行内的每一列
	for(size_t j = 0; j != colCnt; ++j）{
		// 将元素的位置索引作为它的值
		ia[i][j] = i * colCnt + j;
	}
}
```

外层的for循环遍历ia的所有元素， 注意这里的元素是一维数组； 内层的for循环则遍历那些一维数组的整数元素。 此例中， 我们将元素的值设为该元素在整个数组中的序号。



#### 使用范围for语句处理多维数组

由于在C++11新标准中新增了范围for语句， 所以前一个程序可以简化为如下形式：  

```c++
size_t cnt = 0;
for (auto &row : ia)			// 对于外层数组的每一个元素(row相当于一维数组的引用)
	for (auto &col : row){		// 对于内层数组的每一个元素
		col = cnt;				// 将下一个值赋给该元素
		++cnt;					// 将cnt加1
}

// 等价于

for (int (&row)[colCnt] : ia)		// 对于外层数组的每一个元素
	for (int &col : row){			// 对于内层数组的每一个元素
		col = cnt;					// 将下一个值赋给该元素
		++cnt;						// 将cnt加1
}
```

这个循环赋给ia元素的值和之前那个循环是完全相同的， 区别之处是通过使用范围for语句把管理数组索引的任务交给了系统来完成。 因为要改变元素的值， 所以得把控制变量row和col声明成引用类型（参见3.2.3节， 第83页） 。 **第一个for循环遍历ia的所有元素， 这些元素是大小为4的数组， 因此row的类型就应该是含有4个整数的数组的引用。 第二个for循环遍历那些4元素数组中的某一个， 因此col的类型是整数的引用。** 每次迭代把cnt的值赋给ia的当前元素， 然后将cnt加1。

在上面的例子中， 因为要改变数组元素的值， 所以我们选用引用类型作为循环控制变量， 但其实还有一个深层次的原因促使我们这么做。举一个例子， 考虑如下的循环：

```c++
for (const auto &row : ia)			// 对于外层数组的每一个元素
	for (auto col : row)			// 对于内层数组的每一个元素
		cout << col << endl;
```

**这个循环中并没有任何写操作， 可是我们还是将外层循环的控制变量声明成了引用类型， 这是为了避免数组被自动转成指针**（参见3.5.3节， 第105页） 。 假设不用引用类型， 则循环如下述形式：

```c++
for(auto row : ia)
	for (auto col : row)
```

程序将无法通过编译。 这是因为， 像之前一样第一个循环遍历ia的所有元素， 注意这些元素实际上是大小为4的数组。 **因为row不是引用类型， 所以编译器初始化row时会自动将这些数组形式的元素（ 和其他类型的数组一样 ）转换成指向该数组内首元素的指针。 这样得到的row的类型就是int *，显然内层的循环就不合法了，编译器将试图在一个int *内遍历，这显然和程序的初衷相去甚远。**

> 二维数组首元素是变量，所以row的数据类型是int * ，如果是三维数组，则首元素是数组，则row是(*pa)[ ]

<u>**要使用范围for语句处理多维数组， 除了最内层的循环外， 其他所有循环的控制变量都应该是引用类型。**</u>

[范围 for 语句与二维数组](https://blog.csdn.net/abnerwang2014/article/details/26461495)



#### 指针和多维数组

**当程序使用多维数组的名字时， 也会自动将其转换成指向数组首元素的指针。**

**因为多维数组实际上是数组的数组， 所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：**  

```c++
int ia[3][4];				// 大小为3的数组，每个元素是含有4个整数的数组
int (*p)[4] = ia;			// p指向含有4个整数的数组
p = &ia[2]:					// p指向ia的尾元素
```

根据3.5.1节（第103页） 提出的策略， 我们首先明确 (*p) 意味着p是一个指针。 接着观察右边发现， 指针p所指的是一个维度为4的数组； 再观察左边知道， 数组中的元素是整数。 因此， p就是指向含有4个整数的数组的指针。

<u>在上述声明中， 圆括号必不可少：</u>  

```c++
int *ip[4];					// 整型指针的数组
int (*ip)[4];				// 指向含有4个整数的数组
```

**随着C++11新标准的提出， 通过使用auto或者decltype（参见2.5.2节， 第61页） 就能尽可能地避免在数组前面加上一个指针类型了：**

```c++
// 输出ia中每个元素的值，每个内层数组各占一行
// p指向含有4个整数的数组
for (auto p = ia; p != ia + 3; ++p){
	// q指向4个整数数组的首元素，也就是说，q指向一个整数
	for (auto q = *p; q != *p + 4; ++q)		//对指针q解引用，取q所指的元素，即一维数组
		cout << *q << ' '：
	cout << endl;
}
```

外层的for循环首先声明一个指针p 并令其指向 ia 的第一个内层数组， 然后依次迭代直到 ia 的全部3行都处理完为止。 其中递增运算++p负责将指针p 移动到 ia 的下一行。

内层的for循环负责输出内层数组所包含的值。 它首先令指针q指向p当前所在行的第一个元素。 *p是一个含有4个整数的数组， 像往常一样， 数组名被自动地转换成指向该数组首元素的指针。 内层for循环不断迭代直到我们处理完了当前内层数组的所有元素为止。 为了获取内层for循环的终止条件， 再一次解引用p得到指向内层数组首元素的指针， 给它加上4就得到了终止条件。

当然， 使用标准库函数begin和end（参见3.5.3节， 第106页） 也能实现同样的功能， 而且看起来更简洁一些：  

```c++
//p指向ia的第一个数组
for (auto p = begin(ia); p != end(ia); ++p){
	//q指向内层数组的首元素
	for (auto q = begin(*p); q != end(*p); ++q)
		cout << *q << ' ';			// 输出q所指的整数值
	cout << endl;
}
```

在这一版本的程序中， 循环终止条件由end函数负责判断。 虽然我们也能推断出p的类型是指向含有4个整数的数组的指针， q的类型是指向整数的指针， 但是使用auto关键字我们就不必再烦心这些类型到底是什么了。



#### 类型别名简化多维数组的指针

读、 写和理解一个指向多维数组的指针是一个让人不胜其烦的工作， 使用类型别名（参见2.5.1节， 第60页） 能让这项工作变得简单一点儿， 例如：  

```c++
using int_array = int[4];	// 新标准下类型别名的声明，参见2.5.l节（第60页)
typedef int int_array[4];	// 等价的typedef声明，参见2.5.1节（第60页)
// 输出ia中每个元素的值，每个内层数组各占一行
for (int_array *p = ia; p != ia + 3; ++p) {
	for (int *q = *p; q != *p + 4; ++q)
		cout << *q << ' '；
	cout << endl;
}
```

程序将类型“4个整数组成的数组”命名为int_array， 用类型名int_array定义外层循环的控制变量让程序显得简洁明了。  
