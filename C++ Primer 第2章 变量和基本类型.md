# 第2章 变量和基本类型  

## 2.1 基本内置类型  

C++定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。其中算术类型包含了字符、 整型数、 布尔值和浮点数。 空类型不对应具体的值， 仅用于一些特殊的场合， 例如最常见的是， 当函数不返回任何值时使用空类型作为返回类型。  



### 2.1.1 算术类型  

算术类型分为两类： 整型（integral type， 包括字符和布尔类型在内） 和浮点型。

算术类型的尺寸（也就是该类型数据所占的比特数） 在不同机器上有所差别。 表2.1列出了C++标准规定的尺寸的最小值， 同时允许编译器赋予这些类型更大的尺寸。 某一类型所占的比特数不同， 它所能表示的数据范围也不一样。  

![表2-1 C++ 算术类型](C:\Users\Grey\Desktop\C++ Primer\图片\表2-1 C++ 算术类型.png)

布尔类型（bool） 的取值是真（true） 或者假（false） 。

C++提供了几种字符类型， 其中多数支持国际化。 基本的字符类型是char， 一个char的空间应确保可以存放机器基本字符集中任意字符对应的数字值。 也就是说， 一个char的大小和一个机器字节一样。

其他字符类型用于扩展字符集， 如 wchar_t、 char16_t、 char32_t。wchar_t 类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型 char16_t 和 char32_t 则为Unicode字符集服务（Unicode是用于表示所有自然语言中字符的标准） 。  

除字符和布尔类型之外， 其他整型用于表示（可能） 不同尺寸的整数。 **C++语言规定一个int至少和一个short一样大， 一个long至少和一个int一样大， 一个long long至少和一个long一样大。 其中， 数据类型long long是在C++11中新定义的。**  

浮点型可表示单精度、 双精度和扩展精度值。  通常， float以1个字（32比特） 来表示， double以2个字（64比特） 来表示， long double以3或4个字（96或128比特） 来表示。 

 

<u>内置类型的机器实现</u>  

<u>计算机以比特序列存储数据， 每个比特非0即1， 例如：</u>  <u>00011011011100010110010000111011 ...</u>  

<u>大多数计算机以2的整数次幂个比特作为块来处理内存， 可寻址的最小内存块称为“字节（byte） ”， 存储的基本单元称为“字（word） ”， 它通常由几个字节组成。 在C++语言中， 一个字节要至少能容纳机器基本字符集中的字符。 大多数机器的字节由8比特构成， 字则由32或64比特构成， 也就是4或8字节。大多数计算机将内存中的每个字节与一个数字（被称为“地址（address） ”） 关联起来， 在一个字节为8比特、 字为32比特的机器上， 我们可能看到一个字的内存区域如下所示：</u>    

![表2..](C:\Users\Grey\Desktop\C++ Primer\图片\表2...png)

<u>其中， 左侧是字节的地址， 右侧是字节中8比特的具体内容。</u>

<u>我们能够使用某个地址来表示从这个地址开始的大小不同的比特串， 例如， 我们可能会说地址736424的那个字或者地址736427的那个字节。 为了赋予内存中某个地址明确的含义， 必须首先知道存储在该地址的数据的类型。 类型决定了数据所占的比特数以及该如何解释这些比特的内容。</u>

<u>如果位置736424处的对象类型是float， 并且该机器中float以32比特存储， 那么我们就能知道这个对象的内容占满了整个字。 这个float数的实际值依赖于该机器是如何存储浮点数的。 或者如果位置736424处的对象类型是unsigned char， 并且该机器使用ISO-Latin-1字符集， 则该位置处的字节表示一个分号。</u>  



#### 带符号类型和无符号类型

除去布尔型和扩展的字符型之外， 其他整型可以划分为带符号的（signed） 和无符号的（unsigned） 两种。 带符号类型可以表示正数、负数或0， 无符号类型则仅能表示大于等于0的值。

类型int、 short、 long和long long都是带符号的， 通过在这些类型名前添加unsigned就可以得到无符号类型， 例如unsigned long。 类型unsigned int可以缩写为unsigned。

**与其他整型不同， 字符型被分为了三种： char、 signed char 和 unsigned char。 特别需要注意的是： 类型char和类型signed char并不一样。 尽管字符型有三种， 但是字符的表现形式却只有两种： 带符号的和无符号的类型char实际上会表现为上述两种形式中的一种， 具体是哪种由编译器决定。**

无符号类型中所有比特都用来存储值， 例如， 8比特的unsigned char可以表示0至255区间内的值。

C++标准并没有规定带符号类型应如何表示， 但是约定了在表示范围内正值和负值的量应该平衡。 因此， 8比特的signed char理论上应该可以表示-127至127区间内的值， 大多数现代计算机将实际的表示范围定为-128至127。  



#### <u>建议： 如何选择类型</u>

 <u>以下是选择类型的一些经验准则：</u>

​	<u>· 当明确知晓数值不可能为负时， 选用无符号类型。</u>

​	<u>· 使用int执行整数运算。 在实际应用中， short常常显得太小而long一般和int有一样的尺寸。 如果你的数值超过了int的表示范围， 选用long long。</u>

​	<u>· 在算术表达式中不要使用char或bool， 只有在存放字符或布尔值时才使用它们。因为类型char在一些机器上是有符号的， 而在另一些机器上又是无符号的， 所以如果使用char进行运算特别容易出问题。 如果你需要使用一个不大的整数， 那么明确指定它的类型是signed char或者unsigned char。</u>

​	<u>· 执行浮点数运算选用double， 这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。 事实上， 对于某些机器来说， 双精度运算甚至比单精度还快。 long double提供的精度在一般情况下是没有必要的， 况且它带来的运行时消耗也不容忽视。</u>



### 2.1.2 类型转换  

对象的类型定义了对象能包含的数据和能参与的运算， 其中一种运算被大多数类型支持， 就是将对象从一种给定的类型转换（convert） 为另一种相关类型。

当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时， 程序会自动进行类型转换。此处，有必要说明当给某种类型的对象强行赋了另一种类型的值时， 到底会发生什么。

当我们像下面这样把一种算术类型的值赋给另外一种类型时：  

```c++
bool b = 42;				// b为真
int i = b;					// i的值为1
i = 3.14;					// i的值为3
double pi = i;				// pi的值为3.0
unsigned char c = -1;		// 假设char占8比特，c的值为255
signed char c2 = 256;		// 假设char占8比特，c2的值是未定义的
```

类型所能表示的值的范围决定了转换的过程：

​	· 当我们把一个非布尔类型的算术值赋给布尔类型时， 初始值为0则结果为false， 否则结果为true。

​	· 当我们把一个布尔值赋给非布尔类型时， 初始值为false则结果为0， 初始值为true则结果为1。

​	· 当我们把一个浮点数赋给整数类型时， 进行了近似处理。 结果值将仅保留浮点数中小数点之前的部分。

​	· 当我们把一个整数值赋给浮点类型时， 小数部分记为0。 如果该整数所占的空间超过了浮点类型的容量， 精度可能有损失。

​	· 当我们赋给无符号类型一个超出它表示范围的值时， 结果是初始值对无符号类型表示数值总数取模后的余数。 例如， 8比特大小的unsigned char可以表示0至255区间内的值， 如果我们赋了一个区间以外的值， 则实际的结果是该值对256取模后所得的余数。 因此， 把-1赋给8比特大小的unsigned char所得的结果是255（ 先模256，如果不在范围内，再原码变补码：符号位不变，其他位按位取反，末位加一/ 或者256 - 余数的绝对值 ）。

​	· 当我们赋给带符号类型一个超出它表示范围的值时， 结果是未定义的（undefined） 。此时，程序可能继续工作、 可能崩溃， 也可能生成垃圾数据。  

当在程序的某处使用了一种算术类型的值而其实所需的是另一种类型的值时， 编译器同样会执行上述的类型转换。 例如， 如果我们使用了一个非布尔值作为条件， 那么它会被自动地转换成布尔值， 这一做法和把非布尔值赋给布尔变量时的操作完全一样：

```c++
int i = 42;
if (i)		// if条件的值将为true (i的值依然是42)
	i = 0;
```

如果i的值为0， 则条件的值为false； i的所有其他取值（非0） 都将使条件为true。

以此类推， 如果我们把一个布尔值用在算术表达式里， 则它的取值非0即1， 所以一般不宜在算术表达式里使用布尔值。  



#### 含有无符号类型的表达式

尽管我们不会故意给无符号对象赋一个负值， 却可能（特别容易）写出这么做的代码。 例如， **当一个算术表达式中既有无符号数又有int值时， 那个int值就会转换成无符号数。** 把int转换成无符号数的过程和把int直接赋给无符号变量一样：

```c++
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl;		//输出-84
std::cout << u + i << std::endl;		//如果int占32位，输出4294967264

/*

 	整形（int）和无符号整形相加时，int先转化为unsigned int，i在内存中以-42的二进制补码形式存储。
	执行u+i时，i要以unsigned int( 4字节 0 - 4294967295 )的形式读取内存中的数据，将-42的补码(原码变补码：符号位不变，其他按位取反，末位加一)按照unsigned int的形式理解读取（4,294,967,264）
	或者i = -42，转化为 -42 + 2^32(4294967296) = 4,294,967,264（unsinged int）
	
 */
```

在第一个输出表达式里， 两个（负） 整数相加并得到了期望的结果。 在第二个输出表达式里， 相加前首先把整数-42转换成无符号数。把负数转换成无符号数类似于直接给无符号数赋一个负值， 结果等于这个负数加上无符号数的模。  

**当从无符号数中减去一个值时， 不管这个值是不是无符号数， 我们都必须确保结果不能是一个负值：**  

```c++
unsigned u1 = 42,u2 = 10;
std::cout << u1 - u2 << std::endl;		//正确：输出32
std::cout << u2 - u1 << std::endl;		//正确：不过，结果是取模后的值(4,294,967,264)
/*
	-32 + 4294967296 = 4294967264
	或者
	原码变补码：符号位不变，其他按位取反，末位加一
	
	如果类型不匹配，小的会强制转换成大的类型
*/
```

无符号数不会小于0这一事实同样关系到循环的写法。  

```c++
for (int i = 10; i >= 0; --i)
	std::cout << i << std::endl;
```

可能你会觉得反正也不打算输出负数， 可以用无符号数来重写这个循环。 然而， 这个不经意的改变却意味着死循环：  

```c++
//错误：变量ū永远也不会小于0，循环条件一直成立
for (unsigned u = 10; u >= 0; --u)
	std::cout << u << std::endl;
```

来看看当u等于0时发生了什么， 这次迭代输出0， 然后继续执行for语句里的表达式。 表达式--u从u当中减去1， 得到的结果-1并不满足无符号数的要求， 此时像所有表示范围之外的其他数字一样， -1被自动地转换成一个合法的无符号数。 假设int类型占32位， 则当u等于0时， --u的结果将会是4294967295。

一种解决的办法是， 用while语句来代替for语句， 因为前者让我们能够在输出变量之前（而非之后） 先减去1：  

```c++
unsigned u = 11;				//确定要输出的最大数，从比它大1的数开始
while (u > 0){
	--u;						//先减1，这样最后一次迭代时就会输出0
	std::cout << u << std::endl;
}
```

改写后的循环先执行对循环控制变量减1的操作， 这样最后一次迭代时， 进入循环的u值为1。 此时将其减1， 则这次迭代输出的数就是0；下一次再检验循环条件时， u的值等于0而无法再进入循环。 因为我们要先做减1的操作， 所以初始化u的值应该比要输出的最大值大1。 这里， u初始化为11， 输出的最大数是10。  



### 2.1.3 字面值常量  

**一个形如42的值被称作字面值常量**（literal），这样的值一望而知。 每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。



#### 整型和浮点型字面值

我们可以将整型字面值写作十进制数、 八进制数或十六进制数的形式。 以0开头的整数代表八进制数， 以0x或0X开头的代表十六进制数。例如， 我们能用下面的任意一种形式来表示数值20：  

`20 /*十进制*/		024 /*八进制*/		0x14 /*十六进制*/`

整型字面值具体的数据类型由它的值和符号决定。 默认情况下， 十进制字面值是带符号数， 八进制和十六进制字面值既可能是带符号的也可能是无符号的。 十进制字面值的类型是int、 long和long long中尺寸最小的那个（例如， 三者当中最小是int） ， 当然前提是这种类型要能容纳下当前的值。 八进制和十六进制字面值的类型是能容纳其数值的int、unsigned int、 long、 unsigned long、 long long和unsigned long long中的尺寸最小者。 如果一个字面值连与之关联的最大的数据类型都放不下， 将产生错误。 类型short没有对应的字面值。 在表2.2中， 我们将以后缀代表相应的字面值类型。

尽管整型字面值可以存储在带符号数据类型中， 但严格来说， 十进制字面值不会是负数。 如果我们使用了一个形如-42的负十进制字面值， 那个负号并不在字面值之内， 它的作用仅仅是对字面值取负值而已。

浮点型字面值表现为一个小数或以科学计数法表示的指数， 其中指数部分用E或e标识： 默认的， 浮点型字面值是一个double， 我们可以使用表2.2中的后缀来表示其他浮点型。

![表2.2 指定字面值的类型](C:\Users\Grey\Desktop\C++ Primer\图片\表2.2 指定字面值的类型.png)



#### 字符和字符串字面值

由单引号括起来的一个字符称为char型字面值， 双引号括起来的零个或多个字符则构成字符串型字面值。  

```c++
'a' //字符字面值				
"He11oWor1d!" //字符串字面值
```

字符串字面值的类型实际上是由常量字符构成的数组（array）， 编译器在每个字符串的结尾处添加一个空字符（′\0′） ， 因此， 字符串字面值的实际长度要比它的内容多1。 例如， 字面值'A'表示的就是单独的字符A， 而字符串"A"则代表了一个字符的数组， 该数组包含两个字符： 一个是字母A、 另一个是空字符。

如果两个字符串字面值位置紧邻且仅由空格、 缩进和换行符分隔，则它们实际上是一个整体（如下）。 当书写的字符串字面值比较长， 写在一行里不太合适时， 就可以采取分开书写的方式：  

```c++
//分多行书写的字符串字面值
std::cout << "a really,really long string literal"
			"that spans two lines" << std::endl;
```



#### 转义序列  

有两类字符程序员不能直接使用： 一类是不可打印（nonprintable）的字符， 如退格或其他控制字符， 因为它们没有可视的图符； 另一类是在C++语言中有特殊含义的字符（单引号、 双引号、 问号、 反斜线） 。在这些情况下需要用到转义序列（escape sequence），转义序列均以反斜线作为开始， C++语言规定的转义序列包括：  

```c++
换行符  	\n		横向制表符  \t		报警（响铃）符	 \a	
纵向制表符  \v      退格符	   \b		引号			 \"
反斜线		\\	    问号		 \?	  	  单引号		  \'
回车符		\r	    进纸符		\f
```

我们也可以使用泛化的转义序列， 其形式是\x后紧跟1个或多个十六进制数字， 或者\后紧跟1个、 2个或3个八进制数字， 其中数字部分表示的是字符对应的数值。 假设使用的是Latin-1字符集， 以下是一些示例:

`\7（响铃)	\12（换行符)	 \40（空格)	\0（空字符)	\115（字符M)	  \x4d（字符M)`

我们可以像使用普通字符那样使用C++语言定义的转义序列：  

```c++
std::cout << "Hi \x4d0\115！\n";		//输出Hi MOM！,转到新一行
std::cout << '\115' << '\n';		 //输出M,转到新一行
```

注意， **如果反斜线\后面跟着的八进制数字超过3个， 只有前3个数字与\构成转义序列。** 例如， "\1234" 表示2个字符，即八进制数123对应的字符以及字符4。相反，\x要用到后面跟着的所有数字，例如，"\x1234" 表示一个16位的字符， 该字符由这4个十六进制数所对应的比特唯一确定。 因为大多数机器的char型数据占8位（所以只能 \x12, \x34 ...）， 所以上面这个例子可能会报错（"\1234"）。   



#### 指定字面值的类型  

通过添加表2.2中所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。  

```c++
L'a'		// 宽字符型字面值，类型是 wchar_t
u8"hi!"	    // utf-8 字符串字面值 ( utf-8 用 8 位编码一个 Unicode 字符 )
42ULL		// 无符号整型字面值，类型是 unsigned long long
1E-3F		// 单精度浮点型字面值，类型是 float
3.14159L	// 扩展精度浮点型字面值，类型是 long double`
```

<u>当使用一个长整型字面值时， 请使用大写字母L来标记， 因为小写字母l和数字1太容易混淆了。</u>  

对于一个整型字面值来说， 我们能分别指定它是否带符号以及占用多少空间。 如果后缀中有U， 则该字面值属于无符号类型， 也就是说，**以U为后缀的十进制数、 八进制数或十六进制数都将从unsigned int、unsigned long和unsigned long long中选择能匹配的空间最小的一个作为其数据类型。 如果后缀中有L，则字面值的类型至少是long； 如果后缀中有LL， 则字面值的类型将是long long和unsigned long long 中的一种。显然我们可以将U与L或LL合在一起使用。** 例如， 以UL为后缀的字面值的数据类型将根据具体数值情况，取unsigned long， 或者取unsigned long long。  



#### 布尔字面值和指针字面值

true和false是布尔类型的字面值，nullptr是指针字面值，   



## 2.2 变量

**变量提供一个具名的、 可供程序操作的存储空间。** C++中的每个变量都有其数据类型， 数据类型决定着变量所占内存空间的大小和布局方式、 该空间能存储的值的范围， 以及变量能参与的运算。  



### 2.2.1 变量定义

变量定义的基本形式是： 首先是类型说明符（type specifier），随后紧跟由一个或多个变量名组成的列表， 其中变量名以逗号分隔， 最后以分号结束。 列表中每个变量名的类型都由类型说明符指定， 定义时还可以为一个或多个变量赋初值：  

```c++
int sum = 0, value,		// sum、value和units sold都是int
	units_sold = 0;		// sum和units_sold初值为0
Sales_item item;		// item的类型是Sales_item

// string是一种库类型，表示一个可变长的字符序列
std::string book("0-201-78345-X");		// book通过一个string字面值初始化
```

book的定义用到了库类型std::string， 像iostream一样， string也是在命名空间std中定义的，  



#### <u>术语： 何为对象？</u>

<u>C++程序员们在很多场合都会使用对象（object） 这个名词。 通常情况下， 对象是</u><u>指一块能存储数据并具有某种类型的内存空间。</u>

<u>一些人仅在与类有关的场景下才使用“对象”这个词。 另一些人则已把命名的对象和未命名的对象区分开来，他们把命名了的对象叫做变量。还有一些人把对象和值区分开来，其中对象指能被程序修改的数据， 而值（value） 指只读的数据。</u>

<u>**本书遵循大多数人的习惯用法，即认为对象是具有某种数据类型的内存空间。我们在使用对象这个词时 ， 并不严格区分是类还是内置类型， 也不区分是否命名或是否只读。**</u>



#### 初始值

当对象在创建时获得了一个特定的值， 我们说这个对象被初始化（initialized）了。 用于初始化变量的值可以是任意复杂的表达式。 当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。**因此在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。**  

```c++
//正确：price先被定义并赋值，随后被用于初始化discount
double price = 109.99, discount = price * 0.16;
//正确：调用函数applyDiscount,然后用函数的返回值初始化salePrice
double salePrice = applyDiscount ( price, discount );
```

在C++语言中， 初始化是一个异常复杂的问题， 我们也将反复讨论这个问题。 很多程序员对于用等号=来初始化变量的方式倍感困惑， 这种方式容易让人认为初始化是赋值的一种。 事实上在C++语言中， 初始化和赋值是两个完全不同的操作。 然而在很多编程语言中二者的区别几乎可以忽略不计， 即使在C++语言中有时这种区别也无关紧要， 所以人们特别容易把二者混为一谈。

**<u>初始化不是赋值， 初始化的含义是创建变量时赋予其一个初始值， 而赋值的含义是把对象的当前值擦除， 而以一个新值来替代。</u>**  



#### 列表初始化

C++语言定义了初始化的好几种不同形式，这也是初始化问题复杂性的一个体现。例如，要想定义一个名为units_sold的int变量并初始化为0，以下的4条语句都可以做到这一点:  

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

作为C++11新标准的一部分， **用花括号来初始化变量得到了全面应用，这种初始化的形式被称为列表初始化（list initialization）** 。现在，无论是初始化对象还是某些时候为对象赋新值，都可以使用这样一组由花括号括起来的初始值了。

**当用于内置类型的变量时， 这种初始化形式有一个重要特点： 如果我们使用列表初始化且初始值存在丢失信息的风险， 则编译器将报错**：  

```C++
long double ld = 3.1415926536;
int a(ld), b = {ld};		//错误：转换未执行，因为存在丢失信息的危险
int c(ld), d = ld;			//正确：转换执行，且确实丢失了部分值
```



#### 默认初始化

如果定义变量时没有指定初值， 则变量被默认初始化，此时变量被赋予了“默认值”。 默认值到底是什么由变量类型决定， 同时定义变量的位置也会对此有影响。

**如果是内置类型的变量未被显式初始化， 它的值由定义的位置决定。 定义于任何函数体之外的变量被初始化为0。**一种例外情况是， **定义在函数体内部的内置类型变量将不被初始化。 一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。**

**每个类各自决定其初始化对象的方式。 而且， 是否允许不经初始化就定义对象也由类自己决定。** 如果类允许这种行为， 它将决定对象的初始值到底是什么。

绝大多数类都支持无须显式初始化而定义对象， 这样的类提供了一个合适的默认值。 例如，**string类规定如果没有指定初值则生成一个空串。**

一些类要求每个对象都显式初始化， 此时如果创建了一个该类的对象而未对其做明确的初始化操作， 将引发错误。  



<u>**定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化， 则其值由类确定。**</u>



<u>提示： 未初始化变量引发运行时故障</u>  

<u>**建议初始化每一个内置类型的变量**。 虽然并非必须这么做， 但如果我们不能确保初始化后程序安全， 那么这么做不失为一种简单可靠的方法。</u>  



### 2.2.2 变量声明和定义的关系

为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译（separate compilation） 机制， 该机制允许将程序分割为若干个文件， 每个文件可被独立编译。 为了支持分离式编译， C++语言将声明和定义区分开来。 **声明（declaration） 使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义( definition ) 负责创建与名字关联的实体。**

**变量声明规定了变量的类型和名字， 在这一点上定义与之相同。 但是除此之外， 定义还申请存储空间 ， 也可能会为变量赋一个初始值。**

**如果想声明一个变量而非定义它， 就在变量名前添加关键字extern， 而且不要显式地初始化变量**：  

```c++
extern int i;						// 声明i而非定义i
int = j;							// 声明并定义j
```

任何包含了显式初始化的声明即成为定义。 **我们能给由extern关键字标记的变量赋一个初始值， 但是这么做也就抵消了extern的作用。extern语句如果包含初始值就不再是声明， 而变成定义了**：

```c++
extern doub1e pi = 3.1416;			// 定义
```

**在函数体内部， 如果试图初始化一个由extern关键字标记的变量，将引发错误 ( 如果在函数体外部，则不会报错 )**

<u>变量能且只能被定义一次， 但是可以被多次声明</u>  

如果要在多个文件中使用同一个变量，就必须将声明和定义分离。 此时，**变量的定义必须出现在且只能出现在一个文件中， 而其他用到该变量的文件必须对其进行声明， 却绝对不能重复定义。**  

> extern的变量定义时需要有全局作用域，在函数体内部， 如果试图初始化一个由extern关键字标记的变量，将引发错误。如果是别的地方声明可以是函数体内



### 2.2.3 标识符

C++的标识符（identifier） 由字母、 数字和下画线组成， 其中必须以字母或下画线开头。 标识符的长度没有限制， 但是对大小写字母敏感：  

如表2.3和表2.4所示， C++语言保留了一些名字供语言本身使用， 这些名字不能被用作标识符。

![表2.3 C++关键字 & 表2.4 C++操作符替代名](C:\Users\Grey\Desktop\C++ Primer\图片\表2.3 C++关键字 & 表2.4 C++操作符替代名.png)

同时， C++也为标准库保留了一些名字。 用户自定义的标识符中不能连续出现两个下画线， 也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。  



### 2.2.4 名字的作用域

不论是在程序的什么位置， 使用到的每个名字都会指向一个特定的实体：变量、函数、类型等。然而，同一个名字如果出现在程序的不同位置，也可能指向的是不同实体

作用域（scope） 是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以花括号分隔。

**同一个名字在不同的作用域中可能指向不同的实体。**名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。  

```c++
#include <iostream>
int main()
{
	int sum = 0;			//sum用于存放从1到10所有数的和
	for (int val = 1; val <= 10; ++val)
		sum += val;			
		std::cout << "Sum of 1 to 10 inclusive is "
				  << sum << std:endl;
	return 0;
}
```

名字main定义于所有花括号之外，它和其他大多数定义在函数体之外的名字一样拥有全局作用域（ global scope )  。一旦声明之后，全局作用域内的名字在整个程序的范围内都可使用。名字sum定义于main函数所限定的作用域之内，从声明sum开始直到main函数结束为止都可以访问它，但是出了main函数所在的块就无法访问了，因此说变量sum拥有块作用域（block scope） 。名字val定义于for语句内，在for语句之内可以访问val，但是在main函数的其他部分就不能访问它了。  

<u>建议： 当你第一次使用变量时再定义它</u>

<u>**一般来说， 在对象第一次被使用的地方附近定义它是一种好的选择**， 因为这样做有助于更容易地找到变量的定义。 更重要的是， 当变量的定义与它第一次被使用的地方很近时， 我们也会赋给它一个比较合理的初始值。</u>  



#### 嵌套的作用域

作用域能彼此包含， 被包含（或者说被嵌套）的作用域称为内层作用域（inner scope） ，包含着别的作用域的作用域称为外层作用域（outer scope） 。

作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字：  

```c++
#include <iostream>
// 该程序仅用于说明：函数内部不宜定义与全局变量同名的新变量
int reused = 42;			// reused拥有全局作用域
int main()
{
	int unique = 0;			// unique拥有块作用域
	// 输出#1：使用全局变量reused;输出42 0
	std::cout << reused << " " << unique << std::endl;
	int reused = 0;			// 新建局部变量reused,覆盖了全局变量reused
	// 输出#2：使用局部变量reused;输出0 0
	std::cout << reused << " " << unique << std::endl;
	// 输出#3：显式地访问全局变量reused;输出42 0
	std::cout << ::reused << " " << unique << std::endl;
	return 0;
}
```

输出#1出现在局部变量reused定义之前， 因此这条语句使用全局作用域中定义的名字reused， 输出42 0。 输出#2发生在局部变量reused定义之后， 此时局部变量reused正在作用域内（in scope），因此第二条输出语句使用的是局部变量reused而非全局变量，输出0 0。 **输出#3使用作用域操作符（参见1.2节， 第7页） 来覆盖默认的作用域规则， 因为全局作用域本身并没有名字， 所以当作用域操作符的左侧为空时， 向全局作用域发出请求获取作用域操作符右侧名字对应的变量。结果是，第三条输出语句使用全局变量reused ， 输出42 0。**  



## 2.3 复合类型

复合类型（compound type）是指基于其他类型定义的类型。C++语言有几种复合类型，本章将介绍其中的两种：引用和指针。  

与我们已经掌握的变量声明相比，定义复合类型的变量要复杂很多。（ 2.2节,  第38页 ）提到，一条简单的声明语句由一个数据类型和紧随其后的一个变量名列表组成。 其实更通用的描述是，一条声明语句由一个基本数据类型（base type）和紧随其后的一个声明符列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。  



### 2.3.1 引用  

<u>C++11中新增了一种引用： 所谓的“右值引用（rvalue reference） ”， 我们将在 13.6.1节,  （ 第471页 ） 做更详细的介绍。 这种引用主要用于内置类。 严格来说， **当我们使用术语“引用（reference） ”时， 指的其实是“左值引用（lvalue reference）** ”。</u>  

引用（reference） 为对象起了另外一个名字， 引用类型引用（refers to） 另外一种类型。 通过将声明符写成&d的形式来定义引用类型， 其中d是声明的变量名 

```c++
int ival = 1024;
int &refVal = ival;			// refVal指向ival(是ival的另一个名字)
int &refVal2;				// 报错：引用必须被初始化
```

**一般在初始化变量时， 初始值会被拷贝到新建的对象中。 然而定义引用时， 程序把引用和它的初始值绑定（bind） 在一起， 而不是将初始值拷贝给引用。 一旦初始化完成， 引用将和它的初始值对象一直绑定在一起。 因为无法令引用重新绑定到另外一个对象， 因此引用必须初始化。**  

<u>引用即别名:   引用并非对象， 相反的， 它只是为一个已经存在的对象所起的另外一个名字。</u>  

定义了一个引用之后， 对其进行的所有操作都是在与之绑定的对象上进行的：

```c++
refVal = 2;				// 把2赋给refVa1指向的对象，此处即是赋给了ival
int ii = refVal;		// 与ii=ival执行结果一样
```

为引用赋值， 实际上是把值赋给了与引用绑定的对象。 获取引用的值， 实际上是获取了与引用绑定的对象的值。 同理， 以引用作为初始值， 实际上是以与引用绑定的对象作为初始值：  

```c++
// 正确：refVal3绑定到了那个与refVal绑定的对象上，这里就是绑定到ival上
int &refVal3 = refVal;
// 利用与refVa1绑定的对象的值初始化变量i
int i = refVal;					// 正确：i被初始化为ival的值
```

**因为引用本身不是一个对象， 所以不能定义引用的引用。**  



#### 引用的定义

允许在一条语句中定义多个引用， 其中每个引用标识符都必须以符号&开头：  

```c++
int i = 1024, i2 = 2048;			// i和i2都是int
int &r = i, r2 = i2;				// r是一个引用，与i绑定在一起，r2是int
int i3 = 1024, &ri = i3;			// i3是int, ri是一个引用，与i3绑定在一起
int &r3 = i3, &r4 = i2;				// r3和r4都是引用
```

除了2.4.1节（第55页） 和15.2.3节（第534页） 将要介绍的两种例外情况， 其他所有引用的类型都要和与之绑定的对象严格匹配。 而且， **引用只能绑定在对象上， 而不能与字面值或某个表达式的计算结果绑定在一起**， 相关原因将在2.4.1节详述：  

```c++
int &refval4 = 10;					// 错误：引用类型的初始值必须是一个对象
double dval = 3.14;
（ const ）int &refval5 = dval;	   // 错误：此处引用类型的初始值必须是int型对象 ( 但 const 之后可以 )
```



### 2.3.2 指针

指针（pointer） 是“ 指向（point to） ”另外一种类型的复合类型。 **与引用类似， 指针也实现了对其他对象的间接访问。 然而指针与引用相比又有很多不同点。 其一， 指针本身就是一个对象， 允许对指针赋值和拷贝， 而且在指针的生命周期内它可以先后指向几个不同的对象。 其二，指针无须在定义时赋初值。 和其他内置类型一样， 在块作用域内定义的指针如果没有被初始化， 也将拥有一个不确定的值。**  

定义指针类型的方法将声明符写成 *d的形式， 其中d是变量名。 如果在一条语句中定义了几个指针变量， 每个变量前面都必须有符号 * ：  

```c++
int	*ip1, *ip2;			// ip1和ip2都是指向int型对象的指针
double dp, *dp2;		// dp2是指向double型对象的指针，dp是double型对象
```



#### 获取对象的地址

指针存放某个对象的地址， 要想获取该地址， 需要使用取地址符（操作符&） ：

```c++
int ival 42;
int *p = &ival;			// p存放变量ival的地址，或者说p是指向变量ival的指针
```

第二条语句把p定义为一个指向int的指针， 随后初始化p令其指向名为ival的int对象。 **因为引用不是对象， 没有实际地址， 所以不能定义指向引用的指针。**

**除了2.4.2节（第56页） 和15.2.3节（第534页） 将要介绍的两种例外情况， 其他所有指针的类型都要和它所指向的对象严格匹配：**  

```c++
double dval;
double *pd = &dval;			// 正确：初始值是double型对象的地址
double *pd2 = pd;			// 正确：初始值是指向double对象的指针

int *pi = pd;				// 错误：指针p1的类型和pd的类型不匹配
pi = &dval;					// 错误：试图把double型对象的地址赋给int型指针
```

因为在声明语句中指针的类型实际上被用于指定它所指向对象的类型， 所以二者必须匹配。 如果指针指向了一个其他类型的对象， 对该对象的操作将发生错误。  



#### 指针值

指针的值（即地址） 应属下列4种状态之一：

​	1.指向一个对象。

​	2.指向紧邻对象所占空间的下一个位置。

​	3.空指针， 意味着指针没有指向任何对象。

​	4.无效指针， 也就是上述情况之外的其他值。  



#### 利用指针访问对象

如果指针指向了一个对象， 则允许使用解引用符（操作符 * ） 来访问该对象：  

```c++
int ival = 42;
int *p = &ival;			// p存放着变量ival的地址，或者说p是指向变量ival的指针
cout << *p;				// 由符号*得到指针p所指的对象，输出42 	
```

对指针解引用会得出所指的对象， 因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值：  

```c++
*p = 0;			// 由符号*得到指针p所指的对象，即可经由p为变量ival赋值
cout << *p;		// 输出0
```

<u>解引用操作仅适用于那些确实指向了某个对象的有效指针。</u>  



#### 空指针

空指针（null pointer） 不指向任何对象， 在试图使用一个指针之前代码可以首先检查它是否为空。 以下列出几个生成空指针的方法：  

```c++
int *pl = nullptr;			// 等价于int*p1=0;
int *p2 = 0;				// 直接将p2初始化为字面常量0
//需要首先#include cstd1ib
int *p3 = NULL;				// 等价于int *p3 = 0;
```

得到空指针最直接的办法就是用字面值nullptr来初始化指针， 这也是C++11新标准刚刚引入的一种方法。 nullptr是一种特殊类型的字面值， 它可以被转换成（参见2.1.2节， 第32页） 任意其他的指针类型。 另一种办法就如对p2的定义一样， 也可以通过将指针初始化为字面值0来生成空指针。  

过去的程序还会用到一个名为NULL的预处理变量（preprocessor variable） 来给指针赋值， 这个变量在头文件cstdlib中定义， 它的值就是0。  

当用到一个预处理变量时， 预处理器会自动地将它替换为实际值，因此用NULL初始化指针和用0初始化指针是一样的。 **在新标准下， 现在的C++程序最好使用nullptr， 同时尽量避免使用NULL。**  

把int变量直接赋给指针是错误的操作， 即使int变量的值恰好等于0也不行。  

```c++
int zero = 0;
pi = zero;					//错误：不能把int变量直接赋给指针
```



<u>建议： 初始化所有指针</u>  

<u>**建议初始化所有的指针， 并且在可能的情况下， 尽量等定义了对象之后再定义指向它的指针。 如果实在不清楚指针应该指向何处， 就把它初始化为nullptr或者0**，这样程序就能检测并知道它没有指向任何具体的对象了。</u>  



#### 赋值和指针

指针和引用都能提供对其他对象的间接访问， 然而在具体实现细节上二者有很大不同， 其中最重要的一点就是引用本身并非一个对象。 一旦定义了引用， 就无法令其再绑定到另外的对象， 之后每次使用这个引用都是访问它最初绑定的那个对象。

指针和它存放的地址之间就没有这种限制了。 和其他任何变量（只要不是引用） 一样， 给指针赋值就是令它存放一个新的地址， 从而指向一个新的对象：  

```c++
int i = 42;
int *pi = 0;			// pi被初始化，但没有指向任何对象
int *pi2 = &i;			// pi2被初始化，存有i的地址
int *pi3;				// 如果pi3定义于块内，则pi3的值是无法确定的
pi3 = pi2;				// pi3和pi2指向同一个对象i
pi2 = 0;				// 现在pi2不指向任何对象了
```

有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易， 最好的办法就是记住**赋值永远改变的是等号左侧的对象**。   

 

#### 其他指针操作

只要指针拥有一个合法值， 就能将它用在条件表达式中。 和采用算术值作为条件（参见2.1.2节， 第32页） 遵循的规则类似， 如果指针的值是0， 条件取false：  

```c++
int ival = 1024;
int *pi = 0;				//p1合法，是一个空指针
int *pi2 = &ival;			//pi2是一个合法的指针，存放着iva1的地址
if(pi)						//pi的值是0，因此条件的值是false
	// ...
if(pi2)						//pi2指向ival，因此它的值不是0，条件的值是true
	// ...
```

任何非0指针对应的条件值都是true。

对于两个类型相同的合法指针， 可以用相等操作符（==） 或不相等操作符（!=） 来比较它们， 比较的结果是布尔类型。 如果两个指针存放的地址值相同， 则它们相等； 反之它们不相等。 这里两个指针存放的地址值相同（两个指针相等） 有三种可能： 它们都为空、 都指向同一个对象， 或者都指向了同一个对象的下一地址。 需要注意的是，一个指针指向某对象， 同时另一个指针指向另外对象的下一地址， 此时也有可能出现这两个指针值相同的情况， 即指针相等。  



#### void* 指针

void* 是一种特殊的指针类型，可用于存放任意对象的地址。一个void* 指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址中到底是个什么类型的对象并不了解： 

```c++
double obj = 3.14, *pd = &obj;		// 正确：void*能存放任意类型对象的地址
void *pv = &obj;					// obj可以是任意类型的对象
pv = pd;							// pv可以存放任意类型的指针
*pv = 2;							// 错误
```

**以void* 的视角来看内存空间也就仅仅是内存空间， 没办法访问内存空间中所存的对象**  



### 2.3.3 理解复合类型的声明

如前所述，变量的定义包括一个基本数据类型（base type） 和一组声明符。 在同一条定义语句中， 虽然基本数据类型只有一个， 但是声明符的形式却可以不同。 也就是说， 一条定义语句可能定义出不同类型的变量：  

```c++
//i是一个int型的数，p是一个int型指针，r是一个int型引用
int i = 1024,     *p = &i,         &r = i;
```



#### 定义多个变量

经常有一种观点会误以为， 在定义语句中， 类型修饰符（* 或&）作用于本次定义的全部变量。造成这种错误看法的原因有很多，其中之一是我们可以把空格写在类型修饰符和变量名中间：  

` int* pi;							// 合法但是容易产生误导`

我们说这种写法可能产生误导是因为int* 放在一起好像是这条语句中所有变量共同的类型一样。 其实恰恰相反， 基本数据类型是int而非int* 。 *仅仅是修饰了p而已， 对该声明语句中的其他变量， 它并不产生任何作用  

```c++
 int* p1, p2;				// p1是指向int的指针，p2是int
```

涉及指针或引用的声明， 一般有两种写法。 第一种把修饰符和变量标识符写在一起：  

```c++
 int *p1, *p2;				// p1和p2都是指向int的指针
```

第二种把修饰符和类型名写在一起， 并且每条语句只定义一个变量：  

```c++
int* p1;					// p1是指向int的指针
int* p2;		  		    // p2是指向int的指针
```



#### 指向指针的指针  

指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。

通过* 的个数可以区分指针的级别。 也就是说，** 表示指向指针的指针， *** 表示指向指针的指针的指针， 以此类推：  

```c++
int ival = 1024;
int *pi = &ival;				// pi指向一个int型的数
int **ppi = &pi;				// ppi指向一个int型的指针
```

此处pi是指向int型数的指针， 而ppi是指向int型指针的指针  

**解引用int型指针会得到一个int型的数， 同样， 解引用指向指针的指针会得到一个指针。 此时为了访问最原始的那个对象， 需要对指针的指针做两次解引用：**  

```c++
cout << "The value of ival\n"
	 << "direct value: " << ival << "\n" 
	 << "indirect value: " << *pi << "\n"
	 << "doubly indirect value: " << **ppi
	 << endl;
```

该程序使用三种不同的方式输出了变量ival的值： 第一种直接输出； 第二种通过int型指针pi输出； 第三种两次解引用ppi， 取得ival的值。  



#### 指向指针的引用

引用本身不是一个对象， 因此不能定义指向引用的指针。 但**指针是对象， 所以存在对指针的引用：**  

```c++
int i = 42;
int *p;						// p是一个int型指针
int *&r = p;				// r是一个对指针p的引用
r = &i;						// r引用了一个指针，因此给r赋值&i就是令p指向i
*r = 0;						// 解引用r得到i,也就是p指向的对象，将i的值改为0
```

要理解r的类型到底是什么， 最简单的办法是从右向左阅读r的定义。 离变量名最近的符号（此例中是&r的符号&） 对变量的类型有最直接的影响， 因此r是一个引用。 声明符的其余部分用以确定r引用的类型是什么， 此例中的符号* 说明r引用的是一个指针。 最后， 声明的基本数据类型部分指出r引用的是一个int指针。  

<u>面对一条比较复杂的指针或引用的声明语句时， 从右向左阅读有助于弄清楚它的真实含义。</u>  



## 2.4 const限定符

有时我们希望定义这样一种变量， 它的值不能被改变。 例如， 用一个变量来表示缓冲区的大小。 使用变量的好处是当我们觉得缓冲区大小不再合适时， 很容易对其进行调整。 另一方面， 也应随时警惕防止程序一不小心改变了这个值。 为了满足这一要求， 可以用关键字const对变量的类型加以限定：

```c++
const int bufsize = 512;				// 输入缓冲区大小
```

**这样就把bufSize定义成了一个常量。 任何试图为bufSize赋值的行为都将引发错误，因为const对象一旦创建后其值就不能再改变， 所以const对象必须初始化。** 



#### 初始化和const

正如之前反复提到的， 对象的类型决定了其上的操作。 与非const类型所能参与的操作相比， **const类型的对象能完成其中大部分， 但也不是所有的操作都适合。 主要的限制就是只能在const类型的对象上执行不改变其内容的操作。** 例如，const int和普通的int一样都能参与算术运算，也都能转换成一个布尔值等等。  

在不改变const对象的操作中还有一种是初始化， **如果利用一个对象去初始化另外一个对象， 则它们是不是const都无关紧要：**  

```c++
int i = 42;
const int ci = i;			// 正确：i的值被拷贝给了ci
int j = ci;					// 正确：ci的值被拷贝给了j
```

ci的常量特征仅仅在执行改变ci的操作时才会发挥作用。 当用ci去初始化j时， 根本无须在意ci是不是一个常量。 拷贝一个对象的值并不会改变它  



#### 默认状态下， const对象仅在文件内有效

当以编译时初始化的方式定义一个const对象时， 就如对bufSize的定义一样：

```c++
const int bufsize = 512;				// 输入缓冲区大小
```

编译器将在编译过程中把用到该变量的地方都替换成对应的值。 也就是说， 编译器会找到代码中所有用到bufSize的地方， 然后用512替换  

为了执行上述替换， 编译器必须知道变量的初始值。 如果程序包含多个文件， 则每个用了const对象的文件都必须得能访问到它的初始值才行。 要做到这一点， 就必须在每一个用到变量的文件中都有对它的定义（参见2.2.2节， 第41页） 。 为了支持这一用法， 同时避免对同一变量的重复定义， 默认情况下， const对象被设定为仅在文件内有效。 **当多个文件中出现了同名的const变量时， 其实等同于在不同文件中分别定义了独立的变量。**

某些时候有这样一种const变量， 它的初始值不是一个常量表达式，但又确实有必要在文件间共享。 这种情况下， 我们不希望编译器为每个文件分别生成独立的变量。 相反， 我们想让这类const对象像其他（非常量） 对象一样工作， 也就是说， 只在一个文件中定义const， 而在其他多个文件中声明并使用它。

解决的办法是， 对于const变量不管是声明还是定义都添加extern关键字， 这样只需定义一次就可以了：  

```c++
// fi1e1.cc定义并初始化了一个常量，该常量能被其他文件访问，定义时需要全局作用域
extern const int bufsize = fcn();
// fi1e1.h头文件
extern const int bufsize;		//与file1.cc中定义的bufSize是同一个，可以在局部作用域
```

如上述程序所示， file_1.cc定义并初始化了bufSize。 因为这条语句包含了初始值， 所以它（显然） 是一次定义。 然而， 因为bufSize是一个常量， 必须用extern加以限定使其被其他文件使用。

file_1.h头文件中的声明也由extern做了限定， 其作用是指明bufSize并非本文件所独有， 它的定义将在别处出现。  

<u>**如果想在多个文件之间共享const对象， 必须在变量的定义之前添加extern关键字**</u>



### 2.4.1 const的引用

可以把引用绑定到const对象上，就像绑定到其他对象上一样，我们称之为对常量的引用(reference to const) , 与普通引用不同的是，**对常量的引用不能被用作修改它所绑定的对象：**  

```c++
const int ci = 1024;
const int &r1 = ci;				 // 正确：引用及其对应的对象都是常量
r1 = 42;						// 错误：r1是对常量的引用
int &r2 = ci;					// 错误：试图让一个非常量引用指向一个常量对象
```

因为不允许直接为ci赋值， 当然也就不能通过引用去改变ci。 因此， 对r2的初始化是错误的。 假设该初始化合法， 则可以通过r2来改变它引用对象的值， 这显然是不正确的  



<u>术语： 常量引用是对const的引用</u>

<u>C++程序员们经常把词组“对const的引用”简称为“常量引用”， 这一简称还是挺靠谱的， 不过前提是你得时刻记得这就是个简称而已。</u>

<u>严格来说， 并不存在常量引用。 因为引用不是一个对象， 所以我们没法让引用本身恒定不变。 事实上， 由于C++语言并不允许随意改变引用所绑定的对象， 所以从这层意义上理解所有的引用又都算是常量。 引用的对象是常量还是非常量可以决定其所能参与的操作， 却无论如何都不会影响到引用和对象的绑定关系本身。</u>  

> **引用其实是指针常量(int * const)，所以不能指向其他变量，const引用（const int *const）则即不能指向其他变量，又不能改变值**



#### 初始化和对const的引用  

2.3.1节( 第46页 ) 提到，**引用的类型必须与其所引用对象的类型一致，但是有两个例外。 第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值， 只要该表达式的结果能转换成（参见2.1.2节，第32页） 引用的类型即可。** 尤其， 允许为一个常量引用绑定非常量的对象、 字面值， 甚至是个一般表达式：  

```c++
int i = 42;
const int &r1 = i;				// 允许将const int&绑定到一个普通int对象上
const int &r2 = 42;				// 正确：r1是一个常量引用
const int &r3 = r1 * 2;			// 正确：r3是一个常量引用
int &r4 = r1 * 2;				// 错误：r4是一个普通的非常量引用
```

要想理解这种例外情况的原因， 最简单的办法是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么：  

```c++
double dval  = 3.14;
const int &ri = dval;
```

此处ri引用了一个int型的数。 对ri的操作应该是整数运算， 但dval却是一个双精度浮点数而非整数。 因此为了确保让ri绑定一个整数， 编译器把上述代码变成了如下形式：  

```c++
const int temp = dval;			// 由双精度浮点数生成一个临时的整型常量
const int &ri = temp;			// 让r1绑定这个临时量
```

**在这种情况下， ri绑定了一个临时量（temporary） 对象。 所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。C++程序员们常常把临时量对象简称为临时量。**  

**如果ri不是常量， 就允许对ri赋值， 这样就会改变ri所引用对象的值。 注意，此时绑定的对象是一个临时量而非dval。程序员既然让ri引用dval，就肯定想通过ri改变dval的值，否则干什么要给ri赋值呢？ 如此看来， 既然大家基本上不会想着把引用绑定到临时量上， C++语言也就把这种行为归为非法。**  

> **如果ri是常量，则引用临界量（常量）。如果ri不是常量，引用dval，则想通过ri改变dval的值，但引用绑定到临时量上，则会报错。**



#### 对const的引用可能引用一个并非const的对象

必须认识到， **常量引用仅对引用可参与的操作做出了限定， 对于引用的对象本身是不是一个常量未作限定。 因为对象也可能是个非常量，所以允许通过其他途径改变它的值：**

> ```c++
> int i = 42;
> int &r1 = i;				// 引用r1绑定对象i
> const int &r2 = i;			// r2也绑定对象i,但是不允许通过r2修改i的值
> 
> r2 = 1;						// 错误：r2是一个常量引用
> 
> r1 = 0;						// r1并非常量，i的值修改为0
> cout << i << endl;			// 输出为 0
> cout << r1 << endl;			// 输出为 0
> cout << r2 << endl;			// 输出为 0
> 
> i = 3;						// i也可以修改值
> cout << i << endl;			// 输出为 3
> cout << r1 << endl;			// 输出为 3
> cout << r2 << endl;			// 输出为 3
> 
> // 普通引用不能引用常量（const）
> // 普通引用可以引用变量，可以通过变量，引用来修改值
> // 常量引用（const &）可以引用常量，不能通过引用修改值
> // 常量引用（const &）可以引用变量，不能通过引用修改值，但可以通过变量修改值
> ```

r2绑定（非常量） 整数i是合法的行为。 然而， 不允许通过r2修改i的值。 尽管如此， i的值仍然允许通过其他途径修改， 既可以直接给i赋值， 也可以通过像r1一样绑定到i的其他引用来修改。  



### 2.4.2 指针和const

与引用一样， 也可以令指针指向常量或非常量。 类似于常量引用（参见2.4.1节， 第54页） ， 指向常量的指针（pointer to const） 不能用于改变其所指对象的值。 要想存放常量对象的地址， 只能使用指向常量的指针：  

```c++
const double pi = 3.14;			// pi是个常量，它的值不能改变
const double *cptr = &pi;		// 正确：cptr可以指向一个双精度常量
double *ptr = &pi;				// 错误：ptr是一个普通指针
*cptr = 42;						// 错误：不能给*cptr赋值
```

2.3.2节（第47页） 提到， **指针的类型必须与其所指对象的类型一致，但是有两个例外。 第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：**  

```c++
double dval = 3.14;				// dva1是一个双精度浮，点数，它的值可以改变
cptr = &dval;					// 正确：但是不能通过cptr改变dval的值
```

**和常量引用一样， 指向常量的指针也没有规定其所指的对象必须是一个常量。 所谓指向常量的指针仅仅要求不能通过该指针改变对象的值， 而没有规定那个对象的值不能通过其他途径改变。**  

> ```c++
> double pi2 = 3.14;				
> const double *ptr2 = &pi;		// 正确：常量指针ptr2指向pi2
> 
> *ptr2 = 1.0;					// 错误：ptr2是常量指针
> 
> cout << *ptr << endl;			// 输出为 3.14
> cout << pi << endl;				// 输出为 3.14
> 
> // 普通指针不能指向常量（const）
> // 普通指针可以指针变量，可以通过变量，引用来修改值
> // 常量指针（const *）可以指向常量，不能通过解引用修改值
> // 常量指针（const *）可以指向变量，不能通过解引用修改值，但可以通过变量修改值
> ```

<u>试试这样想吧： 所谓指向常量的指针或引用， 不过是指针或引用“自以为是”罢了， 它们觉得自己指向了常量， 所以自觉地不去改变所指对象的值。</u>  

> ```c++
> // 指针常量（指针类型的常量），不能修改指向，可以通过 解引用 修改值，必须初始化
> int * const p = &a;	
> 
> // 常量指针（指向“常量”的指针），不能通过 解引用 修改值，可以修改指向
> const int *p = &a;	
> 
> // 指向常量的指针常量，不能通过 解引用 修改值，也不能修改指向
> const int * const p = &a;		
> ```



#### const指针（注：指针常量，即书上的常量指针）

指针是对象而引用不是， 因此就像其他对象类型一样， 允许把指针本身定为常量。 **常量指针（const pointer） 必须初始化， 而且一旦初始化完成， 则它的值（也就是存放在指针中的那个地址） 就不能再改变了。 把* 放在const关键字之前用以说明指针是一个常量， 这样的书写形式隐含着一层意味， 即不变的是指针本身的值而非指向的那个值：**  

```c++
int errNumb = 0;
int *const curErr = &errNumb;			// curErr将一直指向errNumb

const int errNumb2 = 0;
// 错误 "const int *" 类型的值不能用于初始化 "int *const" 类型的实体
int *const curErr2 = &errNumb2;			// 错误。因为成功的话，可以通过指针修改值

const double pi = 3.14159;
const double *const pip = &pi;			// pip是一个指向常量对象的常量指针
```

如同2.3.3节（第52页） 所讲的， 要想弄清楚这些声明的含义最行之有效的办法是从右向左阅读。 此例中， **离curErr最近的符号是const， 意味着curErr本身是一个常量对象， 对象的类型由声明符的其余部分确定。 声明符中的下一个符号是＊ ， 意思是curErr是一个常量指针。** 最后， 该声明语句的基本数据类型部分确定了常量指针指向的是一个int对象。 与之相似， 我们也能推断出， **pip是一个常量指针， 它指向的对象是一个双精度浮点型常量。**

**指针本身是一个常量并不意味着不能通过指针修改其所指对象的值， 能否这样做完全依赖于所指对象的类型。** 例如， pip是一个指向常量的常量指针， 则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变。 相反的， curErr指向的是一个一般的非常量整数， 那么就完全可以用curErr去修改errNumb的值：  

```c++
*pip = 2.72;				//错误：pip是一个指向常量的指针
//如果curErr所指的对象（也就是errNumb)的值不为O
if (*curErr){
	errorHandler()
	*curErr = 0;			//正确：把curErr所指的对象的值重置
}
```



### 2.4.3 顶层const

如前所述，指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。 **用名词顶层const（top-level const） 表示指针本身是个常量， 而用名词底层const（low-level const） 表示指针所指的对象是一个常量。**

**更一般的， 顶层const可以表示任意的对象是常量， 这一点对任何数据类型都适用， 如算术类型、 类、 指针等。 底层const则与指针和引用等复合类型的基本类型部分有关。 比较特殊的是， 指针类型既可以是顶层const也可以是底层const**， 这一点和其他类型相比区别明显：  

```c++
int i = 0;
int *const p1 = &i;			// 不能改变p1的值，这是一个顶层const
const int ci = 42;			// 不能改变ci的值，这是一个顶层const
const int *p2 = &ci;		// 允许改变p2的值，这是一个底层const
const int *const p3 = p2;	// 靠右的const是顶层const,靠左的是底层const
const int &r = ci;			// 用于声明引用的const都是底层const
```

当执行对象的拷贝操作时， 常量是顶层const还是底层const区别明显。 其中， 顶层const不受什么影响：  

```c++
i = ci;			// 正确：拷贝ci的值，ci是一个顶层const,对此操作无影响
p2 = p3;		// 正确：p2和p3指向的对象类型相同，p3顶层const的部分不影响
```

执行拷贝操作并不会改变被拷贝对象的值， 因此， 拷入和拷出的对象是否是常量都没什么影响。

另一方面， 底层const的限制却不能忽视。 当执行对象的拷贝操作时， 拷入和拷出的对象必须具有相同的底层const资格， 或者两个对象的数据类型必须能够转换。 一般来说， 非常量可以转换成常量， 反之则不行：  

```c++
int *p = p3;			// 错误：p3包含底层const的定义，而p没有
p2 = p3;				// 正确：p2和p3都是底层const
p2 = &i;				// 正确：int*能转换成const int*
int &r = ci;			// 错误：普通的int&不能绑定到int常量上
const int &r2 = i;		// 正确：const int&可以绑定到一个普通int上
```

p3既是顶层const也是底层const， 拷贝p3时可以不在乎它是一个顶层const， 但是必须清楚它指向的对象得是一个常量。因此，不能用p3去初始化p，因为指向的是一个普通的（非常量）整数。另一方面，p3的值可以赋给p2，是因为这两个指针都是底层const，尽管p3同时也是一个常量指针（ 顶层const )，仅就这次赋值而言不会有什么影响。

> **总结：观察左值是否有const，如果有，则右值可以是变量或者常量。如果左值没有，则右值也不能有const（不是指针常量的const，指的是常量指针的const）**
>
> **这里左值，右值狭义为 左边的值，右边的值**



### 2.4.4 constexpr和常量表达式

**常量表达式（const expression） 是指值不会改变并且在编译过程就能得到计算结果的表达式。** 显然， **字面值属于常量表达式， 用常量表达式初始化的const对象也是常量表达式。**   

一个对象（或表达式） 是不是常量表达式由它的数据类型和初始值共同决定， 例如：  

```c++
const int max_files = 20;			// max_files是常量表达式
const int limit = max_files + 1;	 // limit是常量表达式
int staff_size = 27;				// staff_size不是常量表达式
const int sz = get_size();			// sz不是常量表达式
```

尽管staff_size的初始值是个字面值常量， 但由于它的数据类型只是一个普通int而非const int， 所以它不属于常量表达式。 另一方面， 尽管sz本身是一个常量， 但它的具体值直到运行时才能获取到， 所以也不是常量表达式。  



#### constexpr变量  

在一个复杂系统中， 很难（几乎肯定不能） 分辨一个初始值到底是不是常量表达式。 

**C++11新标准规定， 允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。 声明为constexpr的变量一定是一个常量， 而且必须用常量表达式初始化：**    

```c++
constexpr int mf = 20;			// 20是常量表达式
constexpr int limit = mf + 1;	// mf + 1是常量表达式
constexpr int sz = size();		// 只有当size是一个constexpr函数时，才是一条正确的声明语句
```

尽管不能使用普通函数作为constexpr变量的初始值， 但是正如6.5.2节（第214页） 将要介绍的， 新标准允许定义一种特殊的constexpr函数。 这种函数应该足够简单以使得编译时就可以计算其结果， 这样就能用constexpr函数去初始化constexpr变量了。  

<u>一般来说， 如果你认定变量是一个常量表达式， 那就把它声明成constexpr类型。</u>  



#### 字面值类型  

**常量表达式的值需要在编译时就得到计算， 因此对声明constexpr时用到的类型必须有所限制。** 因为这些类型一般比较简单， 值也显而易见、 容易得到， 就把它们称为“字面值类型”（literal type） 

到目前为止接触过的数据类型中， **算术类型、 引用和指针都属于字面值类型。 自定义类Sales_item、 IO库、 string类型则不属于字面值类型， 也就不能被定义成constexpr。** 其他一些字面值类型将在7.5.6节（第267页） 和19.3节（第736页） 介绍。

尽管指针和引用都能定义成constexpr， 但它们的初始值却受到严格限制。 **一个constexpr指针的初始值必须是nullptr或者0， 或者是存储于某个固定地址中的对象。**

6.1.1节（第184页） 将要提到， **函数体内定义的变量一般来说并非存放在固定地址中， 因此constexpr指针不能指向这样的变量。 相反的，定义于所有函数体之外的对象其地址固定不变， 能用来初始化constexpr指针。** 同样是在6.1.1节（第185页） 中还将提到， 允许函数定义一类有效范围超出函数本身的变量， 这类变量和定义在函数体之外的变量一样也有固定地址。 因此， constexpr引用能绑定到这样的变量上， constexpr指针也能指向这样的变量。  



#### 指针和constexpr

**在constexpr声明中如果定义了一个指针， 限定符constexpr仅对指针有效， 与指针所指的对象无关**：  

```c++
const int *p = nullptr;			// p是一个指向整型常量的指针
constexpr int *q = nullptr;		// q是一个指向整数的常量指针
```

p和q的类型相差甚远， p是一个指向常量的指针， 而q是一个常量指针， 其中的关键在于constexpr把它所定义的对象置为了顶层const（参见2.4.3节， 第57页） 。

与其他常量指针类似， constexpr指针既可以指向常量也可以指向一个非常量：  

```c++
constexpr int *np = nullptr;	// np是一个指向整数的常量指针，其值为空
int j = 0;
constexpr int i = 42;			// i的类型是整型常量
// i和j都必须定义在函数体之外
constexpr const int *p = &i;	// p是常量指针，指向整型常量i
constexpr int *p1 = &j;			// p1是常量指针，指向整数j
```



## 2.5 处理类型

### 2.5.1 类型别名

类型别名（type alias） 是一个名字， 它是某种类型的同义词。 使用类型别名有很多好处， 它让复杂的类型名字变得简单明了、 易于理解和使用， 还有助于程序员清楚地知道使用该类型的真实目的。

有两种方法可用于定义类型别名。 传统的方法是使用关键字typedef：  

```c++
typedef double wages;		// wages是double的同义词
typedef wages base, *p;		// base是double的同义词，p是double*的同义词
```

其中， 关键字typedef作为声明语句中的基本数据类型（参见2.3节， 第45页） 的一部分出现。 含有typedef的声明语句定义的不再是变量而是类型别名。 和以前的声明语句一样， 这里的声明符也可以包含类型修饰， 从而也能由基本数据类型构造出复合类型来。

新标准规定了一种新的方法， 使用别名声明（alias declaration） 来定义类型的别名：  

```c++
using SI = Sales_item;		// SI是Sales_item的同义词
```

这种方法用关键字using作为别名声明的开始， 其后紧跟别名和等号， 其作用是把等号左侧的名字规定成等号右侧类型的别名。

类型别名和类型的名字等价， 只要是类型的名字能出现的地方， 就能使用类型别名：  

```c++
wages hourly, weekly;		// 等价于double hourly、weekly;
SI item;					// 等价于Sales_item item
```



#### 指针、 常量和类型别名

如果某个类型别名指代的是复合类型或常量， 那么把它用到声明语句里就会产生意想不到的后果。 例如下面的声明语句用到了类型pstring， 它实际上是类型char＊ 的别名：  

```c++
typedef char* pstring;
const pstring cstr = 0;		// cstr是指向char的常量指针
const pstring *ps;			// ps是一个指针，它的对象是指向char的常量指针
```

上述两条声明语句的基本数据类型都是const pstring，和过去一样，const是对给定类型的修饰。 pstring实际上是指向char的指针， 因此，**const pstring就是指向char的常量指针， 而非指向常量字符的指针。**

遇到一条使用了类型别名的声明语句时， 人们往往会错误地尝试把类型别名替换成它本来的样子， 以理解该语句的含义：  

```c++
const char *cstr = 0;			//是对const pstring cstr的错误理解
```

再强调一遍： 这种理解是错误的。 声明语句中用到pstring时， 其基本数据类型是指针。 可是用char * 重写了声明语句后， 数据类型就变成了char， *成为了声明符的一部分。 这样改写的结果是， const char成了基本数据类型。 前后两种声明含义截然不同， 前者声明了一个指向char的常量指针， 改写后的形式则声明了一个指向const char的指针  



### 2.5.2 auto类型说明符  

编程时常常需要把表达式的值赋给变量， 这就要求在声明变量的时候清楚地知道表达式的类型。 然而要做到这一点并非那么容易， 有时甚至根本做不到。 为了解决这个问题， **C++11新标准引入了auto类型说明符， 用它就能让编译器替我们去分析表达式所属的类型。 和原来那些只对应一种特定类型的说明符( 比如double )不同，auto让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值：**  

```c++
// 由val1和val2相加的结果可以推断出item的类型
auto item = val1 + val2; 				// item初始化为val1和val2相加的结果
```

此处编译器将根据val1和val2相加的结果来推断item的类型。 如果val1和val2是类Sales_item（参见1.5节， 第17页） 的对象， 则item的类型就是Sales_item； 如果这两个变量的类型是double， 则item的类型就是double， 以此类推。

**使用auto也能在一条语句中声明多个变量。 因为一条声明语句只能有一个基本数据类型， 所以该语句中所有变量的初始基本数据类型都必须一样：**  

```c++
auto i = 0, *p = &i;		// 正确：1是整数、p是整型指针
auto sz = 0, pi = 3.14;		// 错误：sz和pi的类型不一致
```



#### 复合类型、 常量和auto

编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。

**首先， 正如我们所熟知的， 使用引用其实是使用引用的对象， 特别是当引用被用作初始值时， 真正参与初始化的其实是引用对象的值。 此时编译器以引用对象的类型作为auto的类型：**  

```c++
int i = 0, &r = i;
auto a = r;			// a是一个整数(r是i的别名，而i是一个整数)
```

其次， **auto一般会忽略掉顶层const（参见2.4.3节， 第57页） ， 同时底层const则会保留下来**， 比如当初始值是一个指向常量的指针时：  

```c++
const int ci = i, &cr = ci;
auto b = ci;		// b是一个整数 (ci的顶层const特性被忽略掉了)
auto c = cr;		// c是一个整数 (cr是ci的别名，ci本身是一个顶层const)
auto d = &i;		// d是一个整型指针 (整数的地址就是指向整数的指针)
auto e = &ci;		// e是一个指向整数常量的指针 (对常量对象取地址是一种底层const)
```

**如果希望推断出的auto类型是一个顶层const， 需要明确指出：**  

```c++
const auto f = ci;			// ci的推演类型是int，f是const int
```

还可以将引用的类型设为auto， 此时原来的初始化规则仍然适用：  

```c++
auto &g = ci;				// g是一个整型常量引用，绑定到ci
auto &h = 42;				// 错误：不能为非常量引用绑定字面值
const auto &j = 42;			// 正确：可以为常量引用绑定字面值
```

设置一个类型为auto的引用时， 初始值中的顶层常量属性仍然保留。 和往常一样， 如果我们给初始值绑定一个引用， 则此时的常量就不是顶层常量了。

要在一条语句中定义多个变量， 切记， 符号&和* 只从属于某个声明符， 而非基本数据类型的一部分， 因此初始值必须是同一种类型：  

```c++
auto k = ci, &l = i;		// k是整数，l是整型引用
auto &m = ci, *p = &ci;		// m是对整型常量的引用，p是指向整型常量的指针
// 错误：i的类型是int而&ci的类型是const int
auto &n = i, *p2 = &ci;
```

> **观察左值和右值，先通过右值，判断左值可能的数据类型，分析与上面顶层const和底层const差不多**



### 2.5.3 decltype类型指示符

有时会遇到这种情况： **希望从表达式的类型推断出要定义的变量的类型， 但是不想用该表达式的值初始化变量。** 为了满足这一要求，**C++11新标准引入了第二种类型说明符decltype， 它的作用是选择并返回操作数的数据类型。 在此过程中， 编译器分析表达式并得到它的类型， 却不实际计算表达式的值：**  

```c++
decltype(f()) sum = x;		// sum的类型就是函数f的返回类型
```

编译器并不实际调用函数f， 而是使用当调用发生时 f 的返回值类型作为sum的类型。 换句话说， 编译器为sum指定的类型是什么呢？ 就是假如 f 被调用的话将会返回的那个类型。

**decltype处理顶层const和引用的方式与auto有些许不同。 如果decltype使用的表达式是一个变量， 则decltype返回该变量的类型（包括顶层const和引用在内） ：**  

```c++
const int ci = 0, &cj = ci;
decltype(ci) x = 0;			// x的类型是const int
decltype(cj) y = x;			// y的类型是const int&, y绑定到变量x
decltype(cj) z;				// 错误：z是一个引用，必须初始化
```

因为cj是一个引用， decltype( cj ) 的结果就是引用类型， 因此作为引用的z必须被初始化。

需要指出的是， 引用从来都作为其所指对象的同义词出现， 只有用在decltype处是一个例外。



#### decltype和引用

**如果decltype使用的表达式不是一个变量， 则decltype返回表达式结果对应的类型。** 如4.1.1节（第120页） 将要介绍的， 有些表达式将向decltype返回一个引用类型。 一般来说当这种情况发生时， 意味着该表达式的结果对象能作为一条赋值语句的左值：  

```c++
//decltype的结果可以是引用类型
int i = 42, *p = &i, &r = i;
decltype(r + 0) b;		// 正确：加法的结果是int，因此b是一个（未初始化的)int
decltype(*p) c;			// 错误：c是int&，必须初始化
decltype(A = B) D = A;   // D 也是 A 的引用
```

因为r是一个引用， 因此decltype(r) 的结果是引用类型。 如果想让结果类型是r所指的类型， 可以把r作为表达式的一部分， 如r+0， 显然这个表达式的结果将是一个具体值而非一个引用。

另一方面， **如果表达式的内容是解引用操作， 则decltype将得到引用类型。** 正如我们所熟悉的那样， 解引用指针可以得到指针所指的对象， 而且还能给这个对象赋值。 因此， decltype( *p )的结果类型就是int&， 而非int。

decltype和auto的另一处重要区别是， decltype的结果类型与表达式形式密切相关。 有一种情况需要特别注意： 对于decltype所用的表达式来说， 如果变量名加上了一对括号， 则得到的类型与不加括号时会有不同。 **如果decltype使用的是一个不加括号的变量， 则得到的结果就是该变量的类型； 如果给变量加上了一层或多层括号， 编译器就会把它当成是一个表达式。 变量是一种可以作为赋值语句左值的特殊表达式， 所以这样的decltype就会得到引用类型：**  

```c++
// decltype的表达式如果是加上了括号的变量，结果将是引用
decltype((i)) d;		// 错误：d是int&，必须初始化
decltype(i) e;			// 正确：e是一个int (未初始化的)
```

**切记： decltype(( variable ))（注意是双层括号） 的结果永远是引用， 而decltype( variable ) 结果只有当variable本身就是一个引用时才是引用。**  



## 2.6 自定义数据结构

从最基本的层面理解， **数据结构是把一组相关的数据元素组织起来然后使用它们的策略和方法。** 举一个例子， 我们的Sales_item类把书本的ISBN编号、 售出量及销售收入等数据组织在了一起， 并且提供诸如isbn函数、 >>、 <<、 +、 +=等运算在内的一系列操作， Sales_item类就是一个数据结构。

C++语言允许用户以类的形式自定义数据类型， 而库类型string、istream、 ostream等也都是以类的形式定义的， 就像第1章的Sales_item类型一样。   



### 2.6.1 定义Sales_data类型

既然我们筹划的这个数据结构不带有任何运算功能， 不妨把它命名为Sales_data以示与Sales_item的区别。 Sales_data初步定义如下：  

```c++
struct Sales_data {
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};
```

我们的类以关键字struct开始， 紧跟着类名和类体（其中类体部分可以为空） 。 类体由花括号包围形成了一个新的作用域（参见2.2.4节，第43页） 。 **类内部定义的名字必须唯一， 但是可以与类外部定义的名字重复。**  

类体右侧的表示结束的花括号后必须写一个分号， 这是因为类体后面可以紧跟变量名以示对该类型对象的定义， 所以分号必不可少：  

```c++
struct Sales_data { /*..*/ } accum, trans, *salesptr;

//与上一条语句等价，但可能更好一些
struct Sales_data { /*..*/ };
Sales_data accum, trans, *salesptr;
```

分号表示声明符（通常为空） 的结束。 一般来说， **最好不要把对象的定义和类的定义放在一起。** 这么做无异于把两种不同实体的定义混在了一条语句里， 一会儿定义类， 一会儿又定义变量， 显然这是一种不被建议的行为。  



#### 类数据成员

类体定义类的成员， 我们的类只有数据成员（data member） 。 **类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。修改一个对象的数据成员，不会影响其他Sales_data的对象。**

定义数据成员的方法和定义普通变量一样： 首先说明一个基本类型， 随后紧跟一个或多个声明符。 我们的类有3个数据成员： 一个名为bookNo的string成员、 一个名为units_sold的unsigned成员和一个名为revenue的double成员。 每个Sales_data的对象都将包括这3个数据成员。

**C++11新标准规定， 可以为数据成员提供一个类内初始值（in-classinitializer） 。 创建对象时， 类内初始值将用于初始化数据成员。 没有初始值的成员将被默认初始化**（参见2.2.1节， 第40页） 。 因此当定义Sales_data的对象时， units_sold和revenue都将初始化为0， bookNo将初始化为空字符串。

对类内初始值的限制与之前（参见2.2.1节， 第39页） 介绍的类似：**或者放在花括号里， 或者放在等号右边， 记住不能使用圆括号。**  

```c++
struct Sales_data {
	std::string bookNo = nullptr;
	unsigned units_sold = { 0 };		// 也可以不要花括号
	double revenue{ 0 };
    int bookId(0);						// 错误
};
```



### 2.6.2 使用Sales_data类  

和Sales_item类不同的是， 我们自定义的Sales_data类没有提供任何操作， Sales_data类的使用者如果想执行什么操作就必须自己动手实现。 例如， 我们将参照1.5.2节（第20页） 的例子写一段程序实现求两次交易相加结果的功能。 程序的输入是下面这两条交易记录：

`0-201-78345-X 3 20.00`

`0-201-78345-X 2 25.00`

每笔交易记录着图书的ISBN编号、 售出数量和售出单价。



#### 添加两个Sales_data对象

因为Sales_data类没有提供任何操作， 所以我们必须自己编码实现输入、 输出和相加的功能。 假设已知Sales_data类定义于Sales_data.h文件内

因为程序比较长， 所以接下来分成几部分介绍。 总的来说， 程序的结构如下：  

```c++
#include <iostream>
#include <string>
#include "Sales_data.h"
int main()
{
	Sales_data data1, data2;
	//读入data1和data2的代码
	//检查data1和data2的ISBN是否相同的代码
	//如果相同，求data1和data2的总和
}
```

和原来的程序一样， 先把所需的头文件包含进来并且定义变量用于接受输入。 和Sales_item类不同的是，新程序还包含了string头文件，因为我们的代码中将用到string类型的成员变量bookNo。  



#### Sales_data对象读入数据

第3章和第10章将详细介绍string类型的细节， 在此之前， 我们先了解一点儿关于string的知识以便定义和使用我们的ISBN成员。 string类型其实就是字符的序列， 它的操作有>>、 <<和==等， 功能分别是读入字符串、 写出字符串和比较字符串。 这样我们就能书写代码读入第一笔交易了：  

```c++
double price = 0;			//书的单价，用于计算销售收入

//读入第1笔交易：ISBN、销售数量、单价
std::cin >> data1.bookNo >> data1.units_sold >> price;

//计算销售收入
data1.revenue = data1.units_sold * price;
```

交易信息记录的是书售出的单价， 而数据结构存储的是一次交易的销售收入， 因此需要将单价读入到double变量price， 然后再计算销售收入revenue。 输入语句  

```c++
std::cin >> data1.bookNo >> data1.units_sold  >> price;
```

使用点操作符（参见1.5.2节， 第20页） 读入对象data1的bookNo成员和units_sold成员。

最后一条语句把data1.units_sold和price的乘积赋值给data1的revenue成员。

接下来程序重复上述过程读入对象data2的数据：  

```c++
//读入第2笔交易
std::cin >> data2.bookNo >> data2.units_sold >> price;
data2.revenue = data2.units_sold * price;
```



#### 输出两个Sales_data对象的和

剩下的工作就是检查两笔交易涉及的ISBN编号是否相同了。 如果相同输出它们的和， 否则输出一条报错信息：  

```c++
if (data1.bookNo == data2.bookNo){
	unsigned totalCnt = data1.units_sold + data2.units_sold;
	double totalRevenue = data1.revenue + data2.revenue;
	// 输出：ISBN、总销售量、总销售额、平均价格
	std::cout << data1.bookNo << " " << totalCnt
	<< " " << tota1Revenue << " ";
	if (totalCnt != 0)
		std::cout << totalRevenue / totalCnt << std::endl;
	else
		std::cout << "(no sales)" << std::endl;
	return 0;			// 标示成功
} else {					// 两笔交易的ISBN不一样
	std::cerr << "Data must refer to the same ISBN"
			  << std::endl;
	return -1;			//标示失败
}
```

在第一个if语句中比较了data1和data2的bookNo成员是否相同。 如果相同则执行第一个if语句花括号内的操作， 首先计算units_sold的和并赋给变量totalCnt， 然后计算revenue的和并赋给变量totalRevenue， 输出这些值。 接下来检查是否确实售出了书籍， 如果是， 计算并输出每本书的平均价格； 如果售量为零， 输出一条相应的信息  



### 2.6.3 编写自己的头文件

尽管如19.7节（第754页） 所讲可以在函数体内定义类， 但是这样的类毕竟受到了一些限制。 所以， 类一般都不定义在函数体内。 当在函数体外部定义类时， 在各个指定的源文件中可能只有一处该类的定义。而且， 如果要在不同文件中使用同一个类， 类的定义就必须保持一致。

为了确保各个文件中类的定义一致， 类通常被定义在头文件中， 而且类所在头文件的名字应与类的名字一样。 例如， 库类型string在名为string的头文件中定义。 又如， 我们应该把Sales_data类定义在名为Sales_data.h的头文件中。

**头文件通常包含那些只能被定义一次的实体， 如类、 const和constexpr变量**（参见2.4节， 第54页） 等。 头文件也经常用到其他头文件的功能。 例如， 我们的Sales_data类包含有一个string成员， 所以Sales_data.h必须包含string.h头文件。 同时， 使用Sales_data类的程序为了能操作bookNo成员需要再一次包含string.h头文件。 这样， 事实上使用Sales_data类的程序就先后两次包含了string.h头文件： 一次是直接包含的， 另有一次是随着包含Sales_data.h被隐式地包含进来的。 有必要在书写头文件时做适当处理， 使其遇到多次包含的情况也能安全和正常地工作。  



#### 预处理器概述

确保头文件多次包含仍能安全工作的常用技术是预处理器（preprocessor） ， 它由C++语言从C语言继承而来。 预处理器是在编译之前执行的一段程序， 可以部分地改变我们所写的程序。 之前已经用到了一项预处理功能#include， 当预处理器看到#include标记时就会用指定的头文件的内容代替#include。

C++程序还会用到的一项预处理功能是头文件保护符（heade rguard） ， 头文件保护符依赖于预处理变量（参见2.3.2节， 第48页） 。**预处理变量有两种状态： 已定义和未定义。#define指令把一个名字设定为预处理变量， 另外两个指令则分别检查某个指定的预处理变量是否已经定义： #ifdef当且仅当变量已定义时为真， #ifndef当且仅当变量未定义时为真。 一旦检查结果为真， 则执行后续操作直至遇到#endif指令为止。**

**使用这些功能就能有效地防止重复包含的发生：**  

```c++
#ifndef SALES_DATA_H
#define SALES_DATA_H

#include <string>
struct Sales_data {
	std::string bookNo;
	unsigned units sold = 0;
	double revenue = 0.0;
};

#endif
```

第一次包含Sales_data.h时， #ifndef的检查结果为真， 预处理器将顺序执行后面的操作直至遇到#endif为止。 此时， 预处理变量SALES_DATA_H的值将变为已定义， 而且Sales_data.h也会被拷贝到我们的程序中来。 后面如果再一次包含Sales_data.h， 则#ifndef的检查结果将为假， 编译器将忽略#ifndef到#endif之间的部分。

整个程序中的预处理变量包括头文件保护符必须唯一， 通常的做法是基于头文件中类的名字来构建保护符的名字， 以确保其唯一性。 **为了避免与程序中的其他实体发生名字冲突， 一般把预处理变量的名字全部大写。**    

<u>预处理变量无视C++语言中关于作用域的规则。</u>
